

\فصل{راهکار پیشنهادی}
\label{ourwork}
تقریباً در تمامی راهکار‌های ارائه‌شده جهت تشخیص برنامک‌های بازبسته‌بندی شده، نیازمند انجام مقایسه‌ی دودویی ویژگی‌های استخراج‌شده از برنامک‌ها در راستای تشخیص جفت تقلبی هستیم. به همین جهت اصولا تشخیص جفت برنامک بازبسته‌بندی شده از میان مخزن‌ برنامک‌ها روشی زمان‌بر و پرهزینه‌است. از طرفی همانطور که بررسی شد، برای تشخیص برنامک‌ بازبسته‌بندی شده، نیازمند ویژگی‌هایی به صورت ایستا و یا پویا از برنامک‌ها هستیم که رفتار منطقی و غیرمنطقی آن‌ها را نشان دهد. از بررسی کار‌های پیشین و مطالعه‌ در زمینه‌ی تحلیل برنامک‌های اندرویدی، می‌توان دریافت که پارامتر‌های دقت و سرعت در تشخیص برنامک‌های بازبسته‌بندی شده، رابطه‌ی مستقیمی با ویژگی‌های منتخب به جهت مقایسه‌ی دودویی برنامک‌ها دارد. پیچیدگی ویژگی‌های منتخب منجر به کاهش سرعت و مقاومت آن‌ها در مقابل روش‌های مبهم‌نگاری، منجر به  افزایش دقت در تشخیص جفت تقلبی خواهد شد. در این فصل ابتدا نمای کلی از پژوهش را توضیح می‌دهیم و مولفه‌های اصلی پژوهش‌ را به صورت مختصر بررسی خواهیم کرد. سپس هر کدام از مولفه‌های مطروحه را با جزئیات بیشتری بررسی و معایب و مزایای هر کدام را شرح خواهیم داد.

\قسمت{نمای کلی}
از آن‌جایی که مقایسه‌ی دودویی برنامک‌ ورودی با تمامی برنامک‌های موجود در مخزن هزینه‌ی محاسباتی زیادی را به پژوهش تحمیل می‌کند،‌ استفاده از یک مرحله پیش‌پردازش می‌تواند به افزایش سرعت تشخیص کمک کند. همانطور که در شکل --- مشخص شده‌است، در این پژوهش از یک طبقه‌بند نزدیک‌ترین همسایه به عنوان مرحله‌ی پیش‌پردازش ورودی‌ها استفاده شده‌است. در این مولفه با استفاده از تعدادی ویژگی‌ مبتنی بر واسط‌های کاربری، برنامک‌های موجود در مخزن و برنامک ورودی طبقه‌بندی و تعدادی از نزدیک‌ترین همسایه‌های برنامک ورودی به عنوان برنامک‌های مشکوک به جهت بررسی دقیق‌تر به مرجله‌ی بعد خواهند رفت. پژوهش به صورت کلی از دومولفه‌ی <<تشخیص کتابخانه‌های اندرویدی>> و <<تشخیص برنامک بازبسته‌بندی‌ شده>> تشکیل شده‌است. مولفه‌ی <<تشخیص کتابخانه‌های اندرویدی>> با الهام از پژوهش \مرجع{msctorki} و همراه با تغییر امضا‌ی کلاسی به جهت افزایش سرعت، پیاده‌سازی شده‌است. مخزن‌ کتاب‌خانه‌های اندرویدی و برنامک هدف، به عنوان ورودی به این مولفه‌ داده می‌شوند. به صورت کلی در این مولفه کلاس‌های هربرنامک،‌ با تمامی کلاس‌های موجود در مخزن کتابخانه‌ها مقایسه‌ می‌شود. برای کاهش فضای مقایسه‌ی کتابخانه‌ها با کلاس‌های برنامک هدف، از <<ماژول فیلتر کتابخانه‌ها>> استفاده شده‌است. این ماژول تعداد کلاس‌های مورد بررسی در هر کتابخانه‌ را با استفاده از دو <<فیلتر ساختاری>> و <<طول امضا>> کاهش می‌دهد و در نهایت با استفاده از توابع چکیده‌سازی محلی، مقایسه‌ی کلاس‌های برنامک هدف و مخزن کتابخانه‌های اندرویدی در ماژول <<استخراج نگاشت>>‌ انجام می‌شود. حل مسئله‌ی نگاشت میان کلاس‌های برنامک و کلاس‌های کتابخانه‌ای، همان حل مسئله‌ی تخصیص است که در آن نگاشتی از کمترین هزینه (مبتنی بر چکیده‌سازی محلی) از یک گراف دوبخشی استخراج می‌شود.\\---------\\ ب
مولفه‌ی دیگری که در این پژوهش پیاده‌سازی شده است، مولفه‌ی تشخیص برنامک‌های بازبسته‌بندی شده است. این مولفه‌، در یک پیش‌پردازی با استفاده از مولفه‌ی تشخیص کتابخانه‌ها، نگاشتی از کلاس‌های برنامک و کلاس‌های کتابخانه‌ای مخزن به دست می‌آورد. سپس دوبرنامک مورد بررسی و نگاشتی از کلاس‌‌های هردو، به عنوان ورودی ماژول طبقه‌بند، وارد می‌شود. برای کاهش فضای مقایسه‌ی دودویی میان برنامک‌های اندرویدی، از یک طبقه‌بند نزدیک‌ترینی همسایه مبتنی بر ویژگی‌های واسط‌های کاربری استفاده شده‌است. این ماژول تعدادی از نزدیک‌ترین همسایه‌های برنامک هدف را به عنوان برنامک‌های مشکوک به ماژول مقایسه‌ی دودویی ارسال می‌کند. در این ماژول ابتدا کد‌های کتابخانه‌ای با استفاده از نگاشت حاصل از مرحله‌ی قبلی حذف می‌شود و کلاس‌های باقی‌مانده برای ساخت امضا توسط ماژول ساخت امضا‌ی برنامک، تحلیل می‌شوند. در نهایت با استفاده از چکیده‌سازی محلی و تعیین حدآستانه، تعیین بازبسته‌بندی صورت می‌گیرد.

\قسمت{تشکیل امضا‌ی کلاس}
در این پژوهش ، مولفه‌ی تشخیص کتابخانه‌های اندرویدی و تشخیص بازبسته‌بندی، هر دو از امضا‌ی کلاس برای شیاهت‌سنجی استفاده کرده‌اند. امضای کلاس‌ متشکل از مهم‌ترین ویژگی‌های آن است که علاوه بر مدل‌کردن رفتار کلاس، مقاومت بالایی در مقابل روش‌های مبهم‌نگاری داشته‌باشد. در ابتدای این قسمت، ابتدا طرح کلی از امضای هر متد را توضیح می‌دهیم، سپس چگونگی ساخته‌شدن امضا‌ی کلاس را با استفاده از امضای متد‌های درون آن شرح خواهیم داد. استخراج ویژگی‌های مبتنی بر کلاس در برنامک‌های اندرویدی در این قسمت با استفاده از چارچوب سوت انجام ‌شده‌است. چارچوب سوت ابزاری مبتنی بر زبان جاوا برای تحلیل ایستای برنامک‌های مبتنی بر این زبان است. \\
از پارامتر‌های زیر برای ساخت امضای متد استفاده شده‌است:
\شروع{فقرات}
\فقره{\textbf{تغییردهنده‌ی متد:}} تغییردهنده‌های هر متد، مشخص‌کننده‌ی چگونگی پیاده‌سازی متد‌های جاوا هستند که اکثرا به سختی قابل تغییر می‌باشند چرا که در صورت تغییر آن‌ها بدنه‌ی متد الزاما باید به صورت کلی تغییر کند، بنابراین استفاده از این ويژگی‌، مقاومت‌ بالایی مقابل مبهم‌نگاری را به ارمغان می‌آورد. برای ساخت امضای متد از ۴ نوع تغییردهنده‌ی بومی، انتزاعی، ایستا و سازنده استفاده شده‌است. متد‌های بومی، شامل دستورات به زبان بومی جاوا هستند که توسط پردازنده به صورت مستقیم اجرا می‌شود. متد‌های ایستا توسط تمامی نمونه‌های کلاس قابل دسترسی هستند و تنها به متغیر‌های ایستا در کلاس دسترسی دارند. متد‌های سازنده، در واقع وظیفه‌ی مقداردهی اولیه به متغیر‌های پویا در هنگام ساخت نمونه‌ی کلاسی در برنامک‌های اندرویدی را بر عهده دارند.

\فقره{\مهم{نوع داده‌ی خروجی و ورودی متد:}} ویژگی دیگری که در امضای متد مورد استفاده قرار گرفته‌است، نوع داده‌ی متغیر‌های خروجی و ورودی به هر متد می‌باشد. به دلیل آن‌که تغییر ورود‌ی و خروجی متد‌ها غالبا بدون تغییر بدنه‌ی اصلی توابع امکان‌پذیر نیست،‌بنابراین تغییر آن‌ها منجر به هزینه‌ی زیادی برای متقلبان است، چرا که نیازمند تغییر بدنه‌ی متد، به طوری که منطق اصلی متد حفظ شود، می‌باشد. 
\فقره{\مهم{متد‌های فراخوانی‌شده‌‌:}} در این قسمت از دو دسته‌‌ی مهم از متد‌هایی که در طول بدنه‌ی برنامک فراخوانی‌شده اند استفاده شده‌است. دسته‌ی اول متد‌هایی هستند که متد‌های کتابخانه‌ای جاوا نیستند و به صورت غیرایستا،  توسط توسعه‌هنده پیاده‌سازی شده‌اند. لازم به ذکر است که به دلیل آن‌که در قسمت تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده، کد‌های کتابخانه‌ای حذف شده‌اند، بنابراین تعریف متد‌های فراخوانی شده در این قسمت، بدون در نظر گرفتن متد‌های کتابخانه‌ای اندرویدی خواهد بود. دسته‌ی دوم متد‌های فراخوانی‌شده، متد‌های زبان جاوا هستند که داخل بسته‌ی کتایخانه‌ای جاوا حضور دارند. تغییر این دسته از متد‌ها آسان‌تر از متد‌های قسمت قبلی است، اما در هر حال نمی‌توان بدون پرداخت هزینه‌ی محاسباتی آن‌ها را حذف کرد.
\فقره{\مهم{فراخوانی واسط‌های برنامه‌نویسی:}} واسط‌های برنامه‌نویسی، هسته‌ی اصلی رفتار هر متد در برنامک‌های اندرویدی هستند که بدافزارنویسان نیز از آن‌ها استفاده می‌کنند. تغییر این دسته از فراخوانی‌ها در متد‌های کلاسی، سخت و با پیچیدگی همراه است.\\
\پایان{فقرات}
در امضای هر کلاس نیز از ویژگی‌های زیر استفاده شده‌است: 
\شروع{فقرات}
\فقره{\textbf{هسته‌ی کلاس:}} هسته‌ی کلاس شامل امضای تمامی متد‌های موجود با استفاده از ویژگی‌های بخش قبل.
\فقره{\مهم{کلاس‌های داخلی:}} از آن‌جا که تغییر سلسله مراتب کلاس‌های جاوایی، اکثرا ناممکن است بنابراین امضای تمامی کلاس‌های داخلی به همراه متد‌های پیاده‌سازی شده در این قسمت استفاده می‌شود. تغییر سلسله مراتب کلاس‌های داخلی نیازمند تغییر تمامی فراخوانی‌های موجود از کلاس‌های مورد نظر است بنابراین تغییر سلسله مراتب تقریبا ممکن نیست.
\فقره{\مهم{سطح کلاس:}} همانطور که گفته‌شد، تغییر سلسله مراتب کلاس‌ها سخت و زمان‌بر است بنابراین شماره‌ی سطح کلاس در ساختار سلسله‌مراتبی ویژگی مقاوم دیگری است که در این قسمت استفاده می‌شود.
\فقره{\مهم{کلاس پدر:}} تغییر ساختار ارث‌بری کلاس‌ها، هزینه‌بر است چرا که تغییر این ساختار نیازمند تغییر فراخوانی‌های متععد ناشی از ساختن نمونه‌های کلاسی است. بنابراین در امضای هر کلاس، از امضای پدر آن کلاس نیز استفاده شده‌است.
\فقره{\مهم{نام کلاس داخلی و بیرونی:}} برای بررسی ریزدانه‌تر، علاوه بر سطح کلاس، از نام کلاس‌های درونی و بیرونی نیز استفاده شده‌است. اکثر مبهم‌نگار‌ها، از دانه‌ی یکسانی برای تولید نام‌های تصادفی استفاده می‌کنند بنابراین ایجاد نام‌های متنوع از یک نام نیازمند تغییر نام اولیه‌ی متد است.
\فقره{\مهم{طول هسته‌ی کلاس:}} طول هسته‌ی کلاس، شامل متد‌های کلاسی و کلاس‌های درونی، ویژگی دیگری است که در امضای کلاس مورد استفاده قرار گرفته‌است. 
\پایان{فقرات}
\قسمت{ساخت امضا} 
از آن‌حایی که امضا برای هر کلاس تولید می‌شوند، بنابراین به صورت کلی دو مرحله برای تولید امضا‌ی کلاس استفاده شده‌است. در ابتدا با استفاده از ویژگی‌های مبتنی بر متد، امضای متد‌های پویای کلاس استحراج شده و سپس با استفاده از طرحی که در ادامه توضیح داده خواهد‌شد امضای کلاس ساخته می‌شود.در ادامه ابتدا نحوه‌ی ساخت امضای متد را توضیح می‌دهیم، سپس به شرح امضای هسته‌ی کلاس و امضای کلاس می‌پردازیم:‌ 
--------
\\
\زیرقسمت{امضای متد} 
به صورت کلی امضای متد از ۵ قسمت متفاوت تشکیل شده‌است:‌
\شروع{شکل}[H]
\centerimg{Method}{16cm}
\vspace{1em}
\شرح{شمای کلی امضای متد در پژوهش}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}
\شروع{فقرات}
\فقره{\مهم{$Modifier$:}} در این بخش رشته‌ای شامل تغییردهنده‌ قرار می‌گیرد. همانطور که در بخش پیشین بررسی کردیم، تغییردهنده‌ی متد، شامل یکی از انواع بومی، انتزاعی، ایستا و یا سازنده‌است. در صورتی که تغییردهنده‌ی متد هیچ‌کدام از موارد ذکر شده نباشد، مقدار $Null$ به جای این ویژگی قرار می‌گیرد.
\فقره{\مهم{$RetType$:}} نوع داده‌ی بازگشتی از متد، به صورت رشته در این قسمت قرار می‌گیرد. در صورتی که نوع داده‌ی متد، از انواع داده‌ای زبان جاوا نباشد، نام کلاس این نوع داده‌ای به صورت رشته جایگزین می‌شود.
\فقره{\مهم{$InputType$}:} نوع داده‌ ورودی‌های متد، مرتب شده به صورت الفبایی، به صورت رشته در این قسمت قرار می‌گیرند. در صورت نبودن نوع داده در زبان جاوا، همانند $RetType$ عمل می‌شود.
\فقره{\مهم{$JLibMethodCallee$:}} رشته‌ای متشکل از تمامی توابع کتابخانه‌ای جاوا، که در بدنه‌ی تابع صدا زده‌شده اند در این قسمت قرار می‌گیرد. رشته‌ی حاصل به صورت الفبایی مرتب شده‌است.
\فقره{\مهم{$NonStaticAppMethodCallee$:}} رشته‌ی مرتب شده به صورت الفبایی شامل نام تمامی توابع غیر کتابخانه‌ای و غیرایستا که توسط تابع فراخوانی شده‌اند. لازم به ذکر است، از آن‌جایی که فراخوانی توابع ایستا، مقاومت بالایی در مقابل مبهم‌نگاری ندارد، در این قسمت از توابع غیر ایستا استفاده شده‌است. افزودن فراخوانی توابع ایستا، یکی از روش‌های محبوب در مبهم‌نگاری برنامک‌های اندرویدی است.
\فقره{\مهم{$ApiCallSootSignature$:}} در این قسمت رشته‌ای از سه ویژگی مهم توابع واسط‌های برنامه‌نویسی، شامل نوع کلاس متد فراخوانی، کلاس نوع بازگشتی متد و نام متد قرار می‌گیرد. تغییر نام واسط‌های برنامه‌نویسی قطعا نیازمند تغییر کتابخانه‌های اندرویدی و ایجاد مبهم‌نگاری در آن‌ها است، به همین دلیل در این قسمت نام متد، مقاوم در مقابل مبهم‌نگاری برنامک می‌باشد.
\پایان{فقرات}

\شروع{شکل}[H]
\centerimg{ApiSootMethodSig}{10cm}
\vspace{1em}
\شرح{شمای کلی امضای واسط‌های برنامه‌نویسی}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\زیرقسمت{امضای کلاس}
امضای کلاس، مطابق با شکل زیر، شامل ۶ قسمت است که در ادامه به بررسی هر کدام می‌پردازیم: 

\شروع{شکل}[H]
\centerimg{ClassSig}{15cm}
\vspace{1em}
\شرح{شمای کلی امضای کلاس}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\شروع{فقرات}
\فقره{$ClassCoreSig$:} رشته‌ی حاصل از الحاق امضای تمامی متد‌های کلاس در این قسمت قرار می‌گیرد. ترتیب قرار‌گرفتن امضای متد‌های کلاس، بر اساس خطوطی است که پیاده‌سازی شده‌اند، یعنی اگر متد $A$ در کلاس $B$ پیش از متد $C$ پیاده‌سازی شده‌بود، آن‌گاه امضای متد $A$ پیش از متد $C$قرار خواهد گرفت.
\شروع{شکل}[H]
\centerimg{MethodConcat}{12cm}
\vspace{1em}
\شرح{شمای کلی هسته‌ی کلاس}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}
\فقره{$InnerClassesSig$:} رشته‌ی حاصل از الحاق امضای کلاس‌های داخلی کلاس مورد نظر، مرتب‌شده به صورت الفبایی در این قسمت قرار خواهد گرفت.
\فقره{$InheritedClassesSig$:} در صورتی که کلاس پدر، یکی از کلاس‌های کتابخانه‌ای جاوا باشد، نام کلاس پدر در این قسمت قرار می‌گیرد، اما در غیر این صورت، امضای کلاس پدر، شامل $CoreClassesSig$ و $ّInnerClassesSig$ به صورت رشته در این قسمت قرار می‌گیرد.

\فقره{$ImpInterfacesSig$:} در صورتی که واسط پیاده‌سازی شده، از نوع کلاس‌های کتابخانه‌ای جاوا باشد، نام آن به صورت رشته در این قسمت قرار خواهد گرفت و در غیر این صورت همانند قسمت قبل، امضای واسط‌ها، شامل الحاق $CoreClassesSig$ و $ّInnerClassesSig$ تمامی آن‌ها، مرتب شده به صورت الفبایی خواهد بود.
\فقره{$ClassLevel$}: عمق کلاس در ساختار سلسله‌مراتبی کلاس‌های هر بسته به صورت عددی در این قسمت قرار خواهد گرفت. برای مثال اگر کلاس مورد نظر، ریشه‌ی درخت سلسله‌مراتیی بسته‌ها باشد، عدد 0 و اگر فقط یک کلاس بیرون داشته باشد ، عدد ۱ در این قسمت قرار خواهد گرفت.
\فقره{$InnerOuterClassesName$}: نام کلاس‌بیرونی و کلاس‌های درونی مرتب‌شده به صورت الفبایی به صورت رشته در این قسمت قرار خواهد گرفت.
\فقره{$ClassLen$}: در این قسمت  طول رشته‌ی امضای کلاس، به صورت عددی درح می‌شود.
\فقره{$NumOfInnerClass$}: تعداد کلاس‌های داخلی کلاس هدف، به صورت عددی در این قسمت قرار می‌گیرد.
\پایان{فقرات}

\قسمت{تشخیص برنامک‌های بازبسته‌بندی شده}
در این قسمت، به بررسی ماژول‌های مولفه‌ی تشخیص‌ برنامک‌های بازبسته‌بندی مطابق با شکل ---- می‌پردازیم.
همانطور که در شکل --- آمده‌است، مولفه‌ی تشخیص کد‌های برنامک‌‌های بازبسته‌بندی شده، شامل سه ماژول پیدا جداسازی کد‌های کتابخانه‌ای، یافتن K نزدیک‌ترین همسایه و مقایسه‌ی دودویی می‌باشد. در ادامه هر کدام از ماژول‌های این مولفه‌ را به دست بررسی می‌کنیم. 
\زیرقسمت{مولفه‌ی تشخیص کد‌های کتابخانه‌ای}
این مولفه‌، دارای سه ماژول اصلی یافتن کلاس‌های کاندید، فیلتر کلاس‌های کاندید مبتنی بر فیلتر‌های ساختاری و طولی و در نهایت ماژول یافتن نگاشت میان کلاس‌های برنامک و کلاس‌های کتابخانه‌ای است.\\
آسان‌ترین روش یافتن کلاس‌های کتابخانه‌ای مقایسه‌ی دودویی کلاس‌های موجود در مخزن کتابخانه‌ها با تمامی کلاس‌های برنامک می‌باشد اما این روش بسیار پر هزینه‌ است، در مرحله‌ی اول از تشخیص کد‌های کتابخانه‌ای با استفاده از دو فیلتر ساختاری و طولی تعداد کلاس‌های مورد مقایسه با برنامک مقصد را کاهش می‌دهیم.در قسمت ابتدایی توسط فیلتر طولی، تنها کلاس‌هایی را بررسی خواهیم کرد که طول آن‌ها از کلاس مبدا از یک حد آستانه کوچکتر و یا بیشتر باشد. در قسمت فیلتر ساختاری، با استفاده از بررسی و تحلیل چندین ویژگی روی کلاس‌های کتابخانه‌ای، مجموعه‌ی کلاس‌هایی که در خروجی فیلتر طولی ظاهر شده‌اند را مجدداً کاهش می‌دهیم. ویژگی‌های مورد بررسی در این قسمت شامل تعداد کلاس‌های بیرونی و داخلی، ارث‌بری کلاسی کلاس هدف، ارث‌بری از کلاس‌های کتابخانه‌ای جاوا و یا اندروید، تعداد واسط‌های پیاده‌سازی شده، واسط‌‌های پیاده‌سازی شده و معادل بودن کلاس‌های بیرونی می‌باشد. کلاس خروجی پس از فیلتر طولی، تنها در صورتی پس از اعمال فیلتر ساختاری نیز حضور خواهد داشت که در تمامی ویژگی‌های ذکر شده با کلاس هدف تطابق داشته‌باشد.\\ 
 در این ماژول تمامی کلاس‌های برنامک و یک کلاس هدف از میان کلاس‌های کتابخانه‌ای به عنوان ورودی به ماژول مورد نظر پاس داده می‌شود و در نهایت لیستی از ماژول‌های کلاس‌های برنامک به عنوان کلاس‌های مشابه در خروجی مشخص می‌شود. شبه‌کد الگوریتم پیداکردن کلاس‌های کاندید در  شکل ~\رجوع{الگوریتم: پیدا‌کردن کلاس‌های کاندید} مشخص شده‌است. پس از اجرای ماژول کلاس‌های کاندیدی،‌ با استفاده از ماژول یافتن کتابخانه‌ها، کتابخانه‌هایی که که کلاسی مشابه در برنامک‌ دارند را شناسایی می‌کنیم. به جهت شناسایی کتابخانه‌‌های موجود در برنامک، پیش از اجرای مولفه‌ی تشخیص کد‌های کتابخانه‌ای، مخزنی شامل کتابخانه‌های اندرویدی مشهور ایجاد می‌کنیم و تمامی کلاس‌های کتابخانه‌ای را در این مخزن قرار می‌دهیم. سپس تعداد $N$ کلاس با طول بیشینه از هر کتابخانه‌ را انتخاب و به عنوان کلاس‌های هدف قرار می‌دهیم. در ادامه، الگوریتم پیدا‌کردن کلاس‌های کاندید ~\رجوع{الگوریتم: پیدا‌کردن کلاس‌های کاندید} را برای هر کدام از کلاس‌های هدف کتابخانه‌ی $lib$ اجرا کرده و تعدادی کلاس کاندید از میان کلاس‌های برنامک انتخاب می‌کنیم. در این مرحله، کلاس‌های کاندید برنامک را با کلاس $Cl$ از کتابخانه‌ی $lib$ با استفاده از روش‌های چکیده‌سازی محلی مقایسه کرده و در صورتی که میزان تشابه دو کلاس بیش از یک حد آستانه باشد، کلاس کاندید مورد نظر با کلاس $Cl$ مطابقت یافته و برای نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک، به مرحله‌ی بعد خواهد رفت. طبیفتا در صورتی که کلاسی در کتابخانه‌ی $lib$ حضور داشته‌باشد، که در خروجی ماژول فیلتر کتابخانه‌ها، حضور پیدا کند، بنابراین کتابخانه‌ی مورد نظر در کد برنامک حضور دارد و برای انجام نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک، به مجموعه‌ی $Libs$ اضافه می‌شود. شبه‌کند ماژول پیدا‌کردن کتابخانه‌ها را می‌توان در الگوریتم --- مشاهده‌نمود.\\ 

  ماژول نگاشت، به جهت ایجاد نگاشتی میان کلاس‌های کتابخانه‌ای (خروجی ماژول فیلتر کتابخانه‌ها)‌ و کلاس‌های برنامک پیاده‌سازی شده‌است. ورودی ماژول لیست $Cls_{lib}$  شامل کلاس‌های کتابخانه‌ای برنامک، حاصل از اجرای الگوریتم ~\رجوع{الگوریتم: فیلتر کتابخانه‌ها} و لیست $Cls_{app}$ کلاس‌های برنامک هدف می‌باشد. خروجی ماژول نگاشتی یک به یک و پوشا از کلاس‌های کتابخانه‌ای به کلاس‌های برنامک می‌باشد و مشخص می‌کند کلام یک از کلاس‌های برنامک، کلاس‌های کتابخانه‌ای هستند. 
  \begin{equation}
  	f: L \rightarrow A  \;\;\;\;\;\;\; L\subseteq Cls_{lib}  \;\;\; , A \subseteq Cls_{app}
  \end{equation}
\شروع{الگوریتم}{پیدا‌کردن کلاس‌های کاندید}
\ورودی کلاس هدف برای یافتن لیستی از کلاس‌های مشابه با آن $t_c$, لیستیی از کلاس‌های برنامک $S_{app}$

\خروجی لیستی از کلاس‌های کاندید برنامک مشابه با کلاس هدف $t_c$

\دستور قرار بده $Candidate = \emptyset$ 
\دستور قرار بده $L= length(Sig_{t_c})$  \توضیحات{مقدار$Sig(t_c)$ امضای نهایی کلاس $t_c$ می‌باشد}\\
\توضیحات{\مهم{فیلتر طولی کلاس‌های برنامک}}
\به‌ازای $Class \in S_{app}$ 
\اگر{$L-T_L < length(Sig_{Class}) < L + T_L$} 
\دستور{ $Candidate \cup  Class$}
\پایان‌اگر
\پایان‌به‌ازای\\
\توضیحات{\مهم{فیلتر ساختاری کلاس‌های برنامک}}
\به‌ازای $Class \in Candidate$ 
\دستور قرار بده $Condition = True$
\دستور قرار بده $Condition= Condition \wedge (\#outerClass(Class) = \#outerClass(t_c))$
\دستور قرار بده $Condition= Condition \wedge (\#InnerClass(Class) = \#InnerClass(t_c))$
\دستور قرار بده $Condition= Condition \wedge (DoesInherit(Class) = DoesInherit(t_c))$
\دستور قرار بده $Condition= Condition \wedge (SDKInherit(Class) = SDKInherit(t_c))$
\دستور قرار بده $Condition= Condition \wedge (\#Interfaces(Class) = \#Interfaces(t_c))$
\دستور قرار بده $Condition= Condition \wedge (SDKInterfaces(Class) = SDKInterfaces(t_c))$
\دستور قرار بده $Condition= Condition \wedge (OuterClass(Class) = OuterClass(t_c))$
\اگر{$Condition \neq True$}
\دستور$Condidate=Condidate - \{Class\}$
\پایان‌اگر
\پایان‌به‌ازای
\پایان{الگوریتم}
 
 در ابتدای این ماژول، کلاس‌های کتابخانه‌ای در سطح $i$ ام را با استفاده از متد $FilterClassByLevel$ محاسبه می‌کنیم و آن‌ را با $S_{lib,i}$ نمایش می‌دهیم. در ادامه به ازای تمامی کلاس‌های موجود در مجموعه‌ی  $S_{lib,i}$، کلاس‌های کاندید را با استفاده از ماژول یافتن کلاس‌های کاندید محاسبه و تحت عنوان $Candidate_{cls}$ ذخیره می‌کنیم.  سپس برای محاسبه‌ی کلاس‌های منطبق بر کلاس هدف، تمامی کلاس‌های کاندید حاصل از مرحله‌ی قبل را با استفاده از توابع چکیده‌سازی محلی، با کلاس هدف مقایسه و در صورتی که میزان تشابه دو کلاس از حد آستانه‌ی $Thr_{s}$ بیشتر بود آنگاه کلاس مورد نظر را به عنوان کلاس تطابق‌داده شده به مجموعه‌ی $Matched_{Class}$ اضافه می‌کنیم.  
 \شروع{الگوریتم}{فیلتر کتابخانه‌ها}
 
 
 \ورودی لیست کلاس‌های برنامک $S_{app}$, مخزن کتابخانه‌های $libs$
 \خروجی لیست کتابخانه‌های استفاده‌شده در برنامک 

 
 \دستور قرار بده $Matched=\emptyset ,Libs = \emptyset$ 

 \به‌ازای $lib \in libs$ 
\دستور قرار بده $GetMaxLengthClasses‬‬(lib,N)‫‪ = TargetClasses$
\به‌ازای $Class \in TargetClasses$
\دستور قرار بده  $Candidates = FindCandidate(Class,S_{app}), Matched_{Class} = \emptyset$   

\به‌ازای $Ca \in Candidates$
\اگر{$FHashCompare(Sig_{ca}, Sig(Class)) > Thr_{F}$}
\دستور قرار بده $Matched_{Class} = Matched_{Class} \cup {Ca}$
\پایان‌اگر
\پایان‌به‌ازای
\دستور قرار بده $Matched = Matched \cup Matched_{class}$
\پایان‌به‌ازای
\اگر{$Matched \neq \emptyset$}
 
 \دستور قرار‌ بده $Libs = Libs \cup lib$
 \پایان‌اگر
\پایان‌به‌ازای\\
\برگردان $Libs$
 \پایان{الگوریتم}
در ادامه سعی می‌شود تا مسئله‌ی پیداکردن کلاس‌های کتابخانه‌ای را به مسئله‌ی تخصیص در یک گراف دوبخشی (حاصل از کلاس‌های کتابخانه‌ای و کلاس‌های برنامک) تبدیل کرد. به همین جهت گراف دو بخشی وزن‌دار  $G$ با تابع هزینه‌ی
 $C\times  ٰV \rightarrow \mathbb{N}$ 
 را با استفاده از کلاس‌های کتابخانه‌ای و کلاس‌های برنامک تشکیل می‌دهیم. گراف G به صورت زیر تعریف می‌شود .
   \begin{equation}
 	G = (U,V,E)
 \end{equation}
\begin{equation}
 	U = \left \{ cls \:| cls \in S_{lib,i} \wedge M_{cls} \neq \o   \right \}
\end{equation}
\begin{equation}
	V = \bigcup_{cls \in U}^{} Matched_{cls}
\end{equation}
\begin{equation}
\left \{ (cls,c)\; | cls \in \; s_{lib,i} \; , c \in Matched_{cls} \right \}
\end{equation}
\begin{equation}
	C(cls,c) = 100 - FhashCompare(Sig_{c} , Sig_{cls})
\end{equation}
\begin{equation}
	FhashCompare: Sig_{1} \times Sig_{2} \rightarrow R \;\;\;\;\; Sig_{1} , Sig_{2} \in ClassesSigs, \; R \in  \mathbb{N}
\end{equation}

\شروع{الگوریتم}{نگاشت کلاس‌های کتابخانه و برنامک}
\ورودی لیست کلاس‌های کتابخانه‌ای برنامک شامل $Cls_{lib}$ , لیست کلاس‌های برنامک شامل $Cls_{apps}$
\خروجی لیستی از دوتایی‌های $(LibraryClass,AppClass)$
\دستور قرار بده $f=\emptyset , i=\emptyset$
\تاوقتی{$Cls_{lib} \neq \emptyset$}
\دستور قرار بده $S_{lib,i} = FilterClassByLevel(S_{lib} , i)$
\دستور قرار بده $S_{lib} = S_{lib} - S_{lib,i}$
\دستور قرار بده $U = \emptyset , V = \emptyset , E = \emptyset$
\به‌ازای{$cls \in S_{lib,i}$}
\دستور قرار بده {$Candidate_{cls} = ‫‪FindCandidates‬‬(cls,Cls_{app})$}
\دستور قرار بده  $M_{cls} = \emptyset$
\به‌ازای $c \in Candidate_{cls}$
\اگر {$FhashCompare(Sig_{c} , Sig_{cls}) > Thr_{s}$}
\دستور قرار بده $Matched_{cls}= Matched_{cls} \cup {c}$
\دستور قرار بده $E = E \cup {(c,cls)}$
\پایان‌اگر
\پایان‌به‌ازای
\اگر {$M_{cls} \neq \emptyset$}
\دستور قرار بده $U = U \cup \{cls\}$
\دستور قرار بده $V = V \cup M_{cls}$
\پایان‌اگر
\پایان‌به‌ازای 
\دستور قرار بده {$f_{i} = ‫‪AssignmentSolver‬‬(U,V,E)$}
\دستور قرار بده $f = f \cup f_{i}$
\دستور قرار بده $i=i+1$
\پایان‌تاوقتی\\
\برگردان $f$
\پایان{الگوریتم}

همانطور که در شکل --- نشان‌ داده‌شده است، گراف G یک گراف دو بخشی حاصل از گره‌های $U$ و $V$ می‌باشد که توسط مجموعه‌ یال‌های $E$ به یکدیگر متصل شده‌اند. برای نگاشت گره‌های مجموع‌ی  $V$ به مجموعه‌ی $U$ از حل مسئله‌ی تخصیص برای سطح $i$، در گراف $G$ استفاده شده‌است.  خروحی ماژول نگاشت کتابخانه‌ها، تابع یک‌به‌یک و پوشا‌ی مشروحه در --- خواهد‌بود. در نهایت اجتماع توابع یک‌به‌یک و پوشای به‌دست آمده به ازای هر یک از کلاس‌های کتابخانه‌ای، خروجی ماژول نگشات می‌باشد که همان نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک می‌باشد.

\زیرقسمت{مولفه‌ی یافتن نزدیک‌ترین همسایه}





