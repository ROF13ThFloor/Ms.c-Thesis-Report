

\فصل{راهکار پیشنهادی} 
\label{ourwork}
تقریباً در تمامی راهکار‌های ارائه‌شده جهت تشخیص برنامک‌های بازبسته‌بندی شده، نیازمند انجام مقایسه‌ی دودویی ویژگی‌های استخراج‌شده از برنامک‌ها در راستای تشخیص جفت تقلبی\پاورقی{Repackaged Pair} هستیم. به همین جهت اصولا تشخیص جفت برنامک بازبسته‌بندی شده از میان مخزن‌ برنامک‌ها روشی زمان‌بر و پرهزینه‌است. از طرفی همانطور که بررسی شد، برای تشخیص برنامک‌ بازبسته‌بندی شده، نیازمند ویژگی‌هایی به صورت ایستا و یا پویا از برنامک‌ها هستیم که رفتار منطقی آن‌ها را نشان دهد. از بررسی کار‌های پیشین و مطالعه‌ در زمینه‌ی تحلیل برنامک‌های اندرویدی، می‌توان دریافت که پارامتر‌های دقت و سرعت در تشخیص برنامک‌های بازبسته‌بندی شده، رابطه‌ی مستقیمی با ویژگی‌های منتخب به جهت مقایسه‌ی دودویی برنامک‌ها دارد. پیچیدگی ویژگی‌های منتخب منجر به کاهش سرعت و مقاومت آن‌ها در مقابل روش‌های مبهم‌نگاری، در نهایت منجر به  افزایش دقت در تشخیص جفت تقلبی خواهد شد. در این فصل ابتدا نمای کلی از پژوهش را توضیح می‌دهیم و مولفه‌های اصلی پژوهش‌ را به صورت مختصر بررسی خواهیم کرد. سپس هر کدام از مولفه‌های مطروحه را با جزئیات بیشتری بررسی و معایب و مزایای هر کدام را شرح خواهیم داد.

\قسمت{راهکار پیشنهادی}
از آن‌جایی که مقایسه‌ی دودویی برنامک‌ ورودی با تمامی برنامک‌های موجود در مخزن، هزینه‌ی محاسباتی زیادی را در روند تشخیص تحمیل می‌کند،‌ استفاده از یک مرحله پیش‌پردازش\پاورقی{Preprocess} می‌تواند به افزایش سرعت تشخیص کمک کند. همانطور که در شکل ~\رجوع{شکل:نمای‌کلی} مشخص شده‌است، راهکار پیشنهادی در این پژوهش به صورت کلی از سه مؤلفه‌ی <<تشخیص کتابخانه‌های اندرویدی>> ، <<یافتن نزدیک‌ترین همسایه>> و <<تشخیص برنامک بازبسته‌بندی‌ شده>> تشکیل شده‌است. مؤلفه‌ی <<تشخیص کتابخانه‌های اندرویدی>> با الهام از پژوهش \مرجع{msctorki} و همراه با تغییر امضا‌ی کلاسی به جهت افزایش سرعت، پیاده‌سازی شده‌است. مخزن‌ کتاب‌خانه‌های اندرویدی و برنامک هدف، به عنوان ورودی به این مؤلفه‌ داده می‌شوند. به صورت کلی در این مؤلفه کلاس‌های هربرنامک،‌ با تمامی کلاس‌های موجود در مخزن کتابخانه‌ها مقایسه‌ می‌شود. برای کاهش فضای مقایسه‌ی کتابخانه‌ها با کلاس‌های برنامک هدف، از <<ماژول فیلتر کتابخانه‌ها>> استفاده شده‌است. این ماژول تعداد کلاس‌های مورد بررسی در هر کتابخانه‌ را با استفاده از دو <<فیلتر ساختاری>> و <<طول امضا>> کاهش می‌دهد و در نهایت با استفاده از توابع چکیده‌سازی محلی\پاورقی{Fuzzy Hashing}، مقایسه‌ی کلاس‌های برنامک هدف و مخزن کتابخانه‌های اندرویدی در ماژول <<استخراج نگاشت>>‌ انجام می‌شود. حل مسئله‌ی نگاشت میان کلاس‌های برنامک و کلاس‌های کتابخانه‌ای، همان حل مسئله‌ی تخصیص\پاورقی{Assignment Problem} است که در آن نگاشتی از کمترین هزینه (مبتنی بر چکیده‌سازی محلی) از یک گراف دوبخشی استخراج می‌شود.
\شروع{شکل}[H]
\centerimg{overview}{16cm}
\vspace{1em}
\شرح{نمای کلی راهکار پیشنهادی}
\برچسب{شکل:نمای‌کلی}
\پایان{شکل}
در این پژوهش از یک طبقه‌بند نزدیک‌ترین همسایه\پاورقی{Nearest neighbor} به عنوان مرحله‌ی پیش‌پردازش ورودی‌ها استفاده شده‌است. در این مؤلفه با استفاده از تعدادی ویژگی‌ مبتنی بر واسط‌های کاربری\پاورقی{User Interface}، برنامک‌های موجود در مخزن و برنامک ورودی هدف طبقه‌بندی\پاورقی{Clustering} و تعدادی از نزدیک‌ترین همسایه‌های برنامک ورودی به عنوان برنامک‌های مشکوک به جهت بررسی دقیق‌تر به مرجله‌ی بعد خواهند رفت.

مؤلفه‌ی دیگری که در این پژوهش پیاده‌سازی شده است، تشخیص برنامک‌های بازبسته‌بندی شده است. این مؤلفه‌، در یک مرحله پیش‌پردازش با استفاده از مؤلفه‌ی تشخیص کتابخانه‌ها، نگاشتی از کلاس‌های برنامک و کلاس‌های کتابخانه‌ای مخزن به دست می‌آورد. سپس دو برنامک مورد بررسی و نگاشتی از کلاس‌‌های هردو، به عنوان ورودی ماژول طبقه‌بند، وارد می‌شود. در مؤلفه‌ی‌ تشخیص برنامک‌های بازبسته‌بندی شده، ابتدا کد‌های کتابخانه‌ای با استفاده از نگاشت حاصل از مرحله‌ی قبلی حذف می‌شوند و کلاس‌های باقی‌مانده برای ساخت امضا توسط ماژول ساخت امضا‌ی برنامک، تحلیل می‌شوند. در نهایت با استفاده از چکیده‌سازی محلی و تعیین یک حدآستانه، تعیین بازبسته‌بندی صورت می‌گیرد.

\قسمت{ساخت امضای‌  برنامک} 
هدف از ساخت امضای\پاورقی{Signature} برنامک، تشکیل مدلی از رفتار منطقی و دستوری آن می‌باشد به طوری که مقاومت بالایی در مقابل راهکار‌های مبهم‌نگاری داشته‌باشد. برای ساخت امضای‌ برنامک از الحاق امضای تمامی کلاس‌های آن استفاده می‌شود. در این پژوهش ، مؤلفه‌ها‌ی تشخیص کتابخانه‌های اندرویدی و تشخیص بازبسته‌بندی، هر دو از امضا‌ی کلاس برای شباهت‌سنجی استفاده کرده‌اند. امضای کلاس‌ متشکل از مهم‌ترین ویژگی‌های آن است که علاوه بر مدل‌کردن رفتار کلاس، مقاومت بالایی در مقابل روش‌های مبهم‌نگاری داشته‌باشد. برای تشخیص کد‌های کتابخانه‌ای، امضای تمامی کلاس‌های جاوا در کتابخانه‌ی مذکور ساخته‌شده و برای تشخیص قسمت‌هایی که شامل‌ کد‌های کتابخانه‌ای در برنامک اندرویدی است استفاده می‌شود.

از آن‌جایی که امضا برای هر کلاس تولید می‌شود، بنابراین به صورت کلی دو مرحله برای تولید امضا‌ی کلاس پیاده‌سازی شده‌است. در ابتدا با استفاده از ویژگی‌های مبتنی بر متد\پاورقی{Method}، امضای متد‌های پویای\پاورقی{Dynamic Method} کلاس استحراج شده و سپس با استفاده از طرحی که در ادامه توضیح داده خواهد‌شد امضای کلاس ساخته می‌شود.در ادامه ابتدا توصیف کلی از تمامی قسمت‌های امضای کلاسی در برنامک ارائه می‌دهیم و دلیل استفاده از این پارامتر را در امضای کلاس عنوان می‌کنیم. سپس ساختار صوری\پاورقی{Formal} تشکیل امضای کلاس‌های برنامک و در نهایت امضای برنامک را شرح می‌دهیم.

\زیرقسمت{توصیف پارامتر‌های امضای برنامک}
در این بخش ویژگی‌های استفاده‌شده در امضای کلاس را شرح می‌دهیم و دلایل استفاده از آن‌ها را عنوان می‌کنیم.
\شروع{فقرات}
\فقره{\textbf{تغییردهنده‌ی متد:}} تغییردهنده‌های هر متد\پاورقی{Method Modifier}، مشخص‌کننده‌ی چگونگی پیاده‌سازی متد‌های جاوا هستند که اکثرا به سختی قابل تغییر می‌باشند چرا که در صورت تغییر آن‌ها بدنه‌ی متد\پاورقی{Method Body} معمولاً باید به صورت کلی تغییر کند، بنابراین استفاده از این ويژگی‌، مقاومت‌ بالایی مقابل مبهم‌نگاری را به ارمغان می‌آورد. برای ساخت امضای متد از چهار نوع تغییردهنده‌ی بومی\پاورقی{Native}، انتزاعی\پاورقی{Abstract}، ایستا\پاورقی{Static} و سازنده \پاورقی{Constructor}استفاده شده‌است. متد‌های بومی، شامل دستورات به زبان بومی جاوا هستند که توسط پردازنده به صورت مستقیم اجرا می‌شود. متد‌های ایستا توسط تمامی نمونه‌های کلاس قابل دسترسی هستند و تنها به متغیر‌های ایستا در کلاس دسترسی دارند. متد‌های سازنده، در واقع وظیفه‌ی مقداردهی اولیه به متغیر‌های پویا در هنگام ساخت نمونه‌ی کلاسی\پاورقی{Class Instance} در برنامک‌های اندرویدی را بر عهده دارند.

\فقره{\مهم{نوع داده‌ی خروجی و ورودی متد:}} ویژگی دیگری که در امضای متد مورد استفاده قرار گرفته‌است، نوع داده‌ی متغیر‌های خروجی و ورودی به هر متد می‌باشد. به دلیل آن‌که تغییر ورود‌ی و خروجی متد‌ها غالبا بدون تغییر بدنه‌ی اصلی توابع امکان‌پذیر نیست، ‌بنابراین تغییر آن‌ها منجر به صرف هزینه‌ی زیادی برای متقلبان می‌شود، چرا که در این صورت نیاز به تغییر بدنه‌ی متد دارند، به طوری که منطق اصلی متد حفظ شود.

\فقره{\مهم{متد‌های فراخوانی‌شده‌‌:}} در این قسمت از دو دسته‌‌ی مهم از متد‌هایی که در بدنه‌ی برنامک فراخوانی‌شده‌اند استفاده شده‌است. دسته‌ی اول متد‌هایی هستند که متد‌های کتابخانه‌ای جاوا نیستند و به صورت غیرایستا،  توسط توسعه‌د‌هنده پیاده‌سازی شده‌اند. لازم به ذکر است که به دلیل آن‌که در قسمت تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده، کد‌های کتابخانه‌ای حذف شده‌اند، بنابراین تعریف متد‌های فراخوانی شده در این قسمت، بدون در نظر گرفتن متد‌های کتابخانه‌ای اندرویدی خواهد بود. دسته‌ی دوم، متد‌های زبان جاوا هستند که داخل بسته‌ی کتابخانه‌ای جاوا حضور دارند. تغییر این دسته از متد‌ها آسان‌تر از متد‌های قسمت قبلی است، اما در هر حال نمی‌توان بدون پرداخت هزینه‌ی محاسباتی آن‌ها را حذف کرد.

\فقره{\مهم{فراخوانی واسط‌های برنامه‌سازی:}} واسط‌های برنامه‌سازی\پاورقی{Application Programming Interface}، هسته‌ی اصلی رفتار هر متد در برنامک‌های اندرویدی هستند که بدافزارنویسان نیز از آن‌ها استفاده می‌کنند. تغییر این دسته از فراخوانی‌ها در متد‌های کلاسی، سخت و با پیچیدگی همراه است.\\
\پایان{فقرات}
در امضای هر کلاس نیز از ویژگی‌های زیر استفاده شده‌است: 
\شروع{فقرات}
\فقره{\textbf{هسته‌ی کلاس:}} هسته‌ی کلاس شامل امضای تمامی متد‌های موجود با استفاده از ویژگی‌های بخش قبل می‌باشد.
\فقره{\مهم{کلاس‌های داخلی:}} از آن‌جا که تغییر سلسله مراتب کلاس‌های جاوایی، اکثرا ناممکن است بنابراین امضای تمامی کلاس‌های داخلی به همراه متد‌های پیاده‌سازی شده در این قسمت استفاده می‌شود. تغییر سلسله مراتب کلاس‌های داخلی نیازمند تغییر تمامی فراخوانی‌های موجود از کلاس‌های مورد نظر است بنابراین تغییر سلسله مراتب تقریبا ممکن نیست.
\فقره{\مهم{سطح کلاس:}} همانطور که گفته‌شد، تغییر سلسله مراتب کلاس‌ها سخت و زمان‌بر است بنابراین شماره‌ی سطح کلاس در ساختار سلسله‌مراتبی، ویژگی مقاوم دیگری است که در این قسمت استفاده می‌شود.
\فقره{\مهم{کلاس پدر:}} تغییر ساختار ارث‌بری کلاس‌ها\پاورقی{Class inheritance}، هزینه‌بر است چرا که تغییر این ساختار نیازمند تغییر فراخوانی‌های متعدد ناشی از ساختن نمونه‌های کلاسی است. بنابراین در امضای هر کلاس، از امضای پدر آن کلاس نیز استفاده شده‌است.
\فقره{\مهم{نام کلاس داخلی و بیرونی:}} برای بررسی ریزدانه‌تر\پاورقی{Fine Grain}، علاوه بر سطح کلاس، از نام کلاس‌های درونی و بیرونی نیز استفاده شده‌است. اکثر مبهم‌نگار‌ها، از بذر‌ یکسانی برای تولید نام‌های تصادفی استفاده می‌کنند بنابراین ایجاد نام‌های متنوع از یک نام نیازمند تغییر نام اولیه‌ی متد است.
\فقره{\مهم{طول هسته‌ی کلاس:}} طول هسته‌ی کلاس، شامل متد‌های کلاسی، ویژگی دیگری است که در امضای کلاس مورد استفاده قرار گرفته‌است. 
\پایان{فقرات}

\زیرقسمت{توصیف صوری امضای متد} 
به صورت کلی امضای متد از ۵ قسمت متفاوت تشکیل شده‌است:
\begin{equation}
\begin{split}
\langle Modifier,RetType,InputType,JLibMethodCallee,\\
NonStaticAppMethodCallee,ApiCallSootSignature\rangle
\end{split}
\end{equation}

%\شروع{شکل}[H]
%\centerimg{Method}{16cm}
%\vspace{1em}
%\شرح{}
%\برچسب{شکل:مبهم‌نگاری‌شناسه}
%\پایان{شکل}
\شروع{فقرات}
\فقره{\مهم{$Modifier$:}} در این بخش رشته‌ای شامل تغییردهنده‌‌ قرار می‌گیرد. همانطور که در بخش پیشین بررسی کردیم، تغییردهنده‌ی متد، شامل یکی از انواع بومی، انتزاعی، ایستا و یا سازنده‌است. در صورتی که تغییردهنده‌ی متد هیچ‌کدام از موارد ذکر شده نباشد، مقدار $Null$ به جای این ویژگی قرار می‌گیرد.
\فقره{\مهم{$RetType$:}} نوع داده‌ی بازگشتی از متد، مرتب‌شده به صورت الفبایی، به صورت رشته در این قسمت قرار می‌گیرد. در صورتی که نوع داده‌ی متد، از انواع داده‌ای زبان جاوا نباشد، نام کلاس این نوع داده‌ای به صورت رشته جایگزین می‌شود.
\فقره{\مهم{$InputType$}:} نوع داده‌ ورودی‌های متد، مرتب شده به صورت الفبایی، به صورت رشته در این قسمت قرار می‌گیرند. در صورت نبودن نوع داده در زبان جاوا، همانند $RetType$ عمل می‌شود.
\فقره{\مهم{$JLibMethodCallee$:}} رشته‌ای متشکل از تمامی توابع کتابخانه‌ای جاوا، که در بدنه‌ی اصلی متد صدا زده‌شده‌اند در این قسمت قرار می‌گیرد. رشته‌ی حاصل به صورت الفبایی مرتب شده‌است.
\فقره{\مهم{$NonStaticAppMethodCallee$:}} رشته‌ی مرتب شده به صورت الفبایی شامل نام تمامی توابع غیر کتابخانه‌ای و غیرایستا که توسط تابع فراخوانی شده‌اند. لازم به ذکر است، از آن‌جایی که فراخوانی توابع ایستا، مقاومت بالایی در مقابل مبهم‌نگاری ندارد، در این قسمت از توابع غیر ایستا استفاده شده‌است. افزودن فراخوانی توابع ایستا، یکی از روش‌های محبوب در مبهم‌نگاری برنامک‌های اندرویدی است.
\فقره{\مهم{$ApiCallSootSignature$:}} در این قسمت رشته‌ای از سه ویژگی مهم توابع واسط‌های برنامه‌نویسی، شامل نوع کلاس متد فراخوانی، کلاس نوع بازگشتی متد و نام متد قرار می‌گیرد. تغییر نام واسط‌های برنامه‌نویسی قطعا نیازمند تغییر کتابخانه‌های اندرویدی و ایجاد مبهم‌نگاری در آن‌ها است، به همین دلیل در این قسمت نام متد، تا حدودی مقاوم در مقابل مبهم‌نگاری برنامک می‌باشد.
\begin{equation}
\begin{split}
\langle DeclaringClass,RetType,MethodName \rangle
\end{split}
\end{equation}
\پایان{فقرات}

%\شروع{شکل}[H]
%\centerimg{ApiSootMethodSig}{10cm}
%\vspace{1em}
%\شرح{شمای کلی امضای واسط‌های برنامه‌نویسی}
%\برچسب{شکل:مبهم‌نگاری‌شناسه}
%\پایان{شکل}

\زیرقسمت{توصیف صوری امضای کلاس}
امضای کلاس، شامل ۶ قسمت است که در ادامه به بررسی هر کدام از آن‌ها می‌پردازیم: 
\begin{equation}
\begin{split}
\langle ClassCoreSig,InnerClassesSig,InheritedClassesSig,ImpInterfacesSig\\
,ClassLevel,InnerOuterClassName,ClassLen,NumofInnerClass \rangle
\end{split}
\end{equation}
%\شروع{شکل}[H]
%\centerimg{ClassSig}{15cm}
%\vspace{1em}
%\شرح{شمای کلی امضای کلاس}
%\برچسب{شکل:امضاکلاس}
%\پایان{شکل}

\شروع{فقرات}
\فقره{$ClassCoreSig$:} رشته‌ی حاصل از الحاق امضای تمامی متد‌های کلاس در این قسمت قرار می‌گیرد. ترتیب قرار‌گرفتن امضای متد‌های کلاس، بر اساس خطوطی است که پیاده‌سازی شده‌اند، یعنی اگر متد $A$ در کلاس $B$ پیش از متد $C$ پیاده‌سازی شده‌بود، آن‌گاه امضای متد $A$ پیش از متد $C$ قرار خواهد گرفت.
\begin{equation}
\begin{split}
\langle MethodSig_1,MethodSig_2, ...., MethodSig_n \rangle
\end{split}
\end{equation}
%\شروع{شکل}[H]
%\centerimg{MethodConcat}{12cm}
%\vspace{1em}
%\شرح{شمای کلی هسته‌ی کلاس}
%\برچسب{شکل:هسته‌کلاس}
%\پایان{شکل}
\فقره{$InnerClassesSig$:} رشته‌ی حاصل از الحاق امضای کلاس‌های داخلی کلاس مورد نظر، مرتب‌شده به صورت الفبایی در این قسمت قرار خواهد گرفت.
\فقره{$InheritedClassesSig$:} در صورتی که کلاس پدر\پاورقی{Parent Class}، یکی از کلاس‌های کتابخانه‌ای جاوا باشد، نام کلاس پدر در این قسمت قرار می‌گیرد، اما در غیر این صورت، امضای کلاس پدر، شامل $CoreClassesSig$ و $ّInnerClassesSig$ به صورت رشته در این قسمت قرار می‌گیرد.

\فقره{$ImpInterfacesSig$:} در صورتی که واسط پیاده‌سازی شده\پاورقی{Implemented Interface}، از نوع کلاس‌های کتابخانه‌ای جاوا باشد، نام آن به صورت رشته در این قسمت قرار خواهد گرفت و در غیر این صورت همانند قسمت قبل، امضای واسط‌ها، شامل الحاق $CoreClassesSig$ و $ّInnerClassesSig$ تمامی آن‌ها، مرتب شده به صورت الفبایی خواهد بود.
\فقره{$ClassLevel$}: عمق کلاس\پاورقی{Class's Depth} در ساختار سلسله‌مراتبی کلاس‌های هر بسته به صورت عددی در این قسمت قرار خواهد گرفت. برای مثال اگر کلاس مورد نظر، ریشه‌ی درخت سلسله‌مراتبی بسته‌ها باشد، عدد 0 و اگر فقط یک کلاس بیرونی داشته باشد ، عدد ۱ در این قسمت قرار خواهد گرفت.
\فقره{$InnerOuterClassesName$}: نام کلاس‌بیرونی و کلاس‌های درونی مرتب‌شده به صورت الفبایی به صورت رشته در این قسمت قرار خواهد گرفت.
\فقره{$ClassLen$}: در این قسمت  طول رشته‌ی امضای کلاس، به صورت عددی درج می‌شود.
\فقره{$NumOfInnerClass$}: تعداد کلاس‌های داخلی کلاس هدف، به صورت عددی در این قسمت قرار می‌گیرد.
\پایان{فقرات}

\قسمت{مؤلفه‌های تشخیص برنامک‌های بازبسته‌بندی شده}
در این قسمت به بررسی ماژول\پاورقی{Module}‌های هر کدام از سه مؤلفه‌ی تشخیص برنامک‌های بازبسته‌بندی شده می‌پردازیم.
\زیرقسمت{مؤلفه‌ی تشخیص کد‌های کتابخانه‌ای}
با توجه به تصویر ~\رجوع{شکل:مولفه‌تشخیص‌کتابخانه}، این مؤلفه‌ دارای سه ماژول اصلی یافتن کلاس‌های کاندید\پاورقی{Candidate}، فیلتر کلاس‌های کاندید مبتنی بر فیلتر‌های ساختاری\پاورقی{Structural} و طول امضا و در نهایت ماژول یافتن نگاشت\پاورقی{Mapping} میان کلاس‌های برنامک و کلاس‌های کتابخانه‌ای است.

آسان ‌ترین روش یافتن کلاس‌های کتابخانه‌ای مقایسه‌ی دودویی کلاس‌های موجود در مخزن کتابخانه‌ها با تمامی کلاس‌های برنامک می‌باشد اما این روش بسیار پرهزینه‌ است، به همین جهت در مرحله‌ی اول از تشخیص کد‌های کتابخانه‌ای با استفاده از دو فیلتر ساختاری و طولی، تعداد کلاس‌های مورد مقایسه با برنامک مقصد را کاهش می‌دهیم. در قسمت ابتدایی توسط فیلتر طولی، تنها کلاس‌هایی را بررسی خواهیم کرد که طول آن‌ها از کلاس مبدا از یک حد آستانه\پاورقی{Threshold} $Thr_L$ فاصله‌ داشته‌باشد. در قسمت فیلتر ساختاری، با استفاده از بررسی و تحلیل چندین ویژگی روی کلاس‌های کتابخانه‌ای، مجموعه‌ی کلاس‌هایی که در خروجی فیلتر طولی ظاهر شده‌اند را مجدداً کاهش می‌دهیم. ویژگی‌های مورد بررسی در این قسمت شامل تعداد کلاس‌های بیرونی و داخلی، ارث‌بری کلاسی کلاس هدف، ارث‌بری از کلاس‌های کتابخانه‌ای جاوا و یا اندروید، تعداد واسط‌های پیاده‌سازی شده و معادل بودن کلاس‌های بیرونی می‌باشد. کلاس خروجی پس از فیلتر طولی، تنها در صورتی بعد از اعمال فیلتر ساختاری نیز حضور خواهد داشت که در تمامی ویژگی‌های ذکر شده با کلاس هدف تطابق داشته‌باشد. شبه‌کد این رویه در الگوریتم ~\رجوع{الگوریتم: فیلتر ‌کتابخانه‌ها} مشخص شده‌‌است. \\ 
\شروع{شکل}[H]
\centerimg{libdetection}{16cm}
\vspace{1em}
\شرح{نمای کلی مؤلفه‌ی تشخیص کد‌های کتابخانه‌ای}
\برچسب{شکل:مولفه‌تشخیص‌کتابخانه}
\پایان{شکل}
در ماژول پیداکردن کلاس‌های کاندید، تمامی کلاس‌های برنامک و یک کلاس هدف از میان کلاس‌های کتابخانه‌ای به عنوان ورودی به ماژول مورد نظر ارسال می‌شود و در نهایت لیستی از کلاس‌های برنامک به عنوان کلاس‌های مشابه در خروجی مشخص می‌شود. شبه‌کد رویه‌ی پیداکردن کلاس‌های کاندید در الگوریتم ~\رجوع{الگوریتم: پیدا‌کردن کلاس‌های کاندید} مشخص شده‌است. پس از اجرای ماژول پیدا‌کردن کلاس‌های کاندید،‌ کتابخانه‌هایی که که کلاسی مشابه در برنامک‌ دارند را شناسایی می‌کنیم. به جهت شناسایی کتابخانه‌‌های موجود در برنامک، پیش از اجرای مولفه‌ی تشخیص کد‌های کتابخانه‌ای، مخزنی شامل کتابخانه‌های اندرویدی مشهور ایجاد می‌کنیم و تمامی کلاس‌های کتابخانه‌ای را در این مخزن قرار می‌دهیم. سپس تعداد $N$ کلاس با طول بیشینه از هر کتابخانه‌ را انتخاب و به عنوان کلاس‌های هدف قرار می‌دهیم. در ادامه، الگوریتم پیدا‌کردن کلاس‌های کاندید را برای هر کدام از کلاس‌های هدف کتابخانه‌ی $lib$ اجرا کرده و تعدادی کلاس کاندید از میان کلاس‌های برنامک انتخاب می‌کنیم. در این مرحله، کلاس‌های کاندید برنامک را با کلاس $Class$ از کتابخانه‌ی $lib$ با استفاده از روش‌های چکیده‌سازی محلی مقایسه کرده و در صورتی که میزان شباهت دو کلاس بیش از یک حد آستانه $Thr_f$ باشد، کلاس کاندید مورد نظر با کلاس $Class$ مطابقت یافته و برای نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک، به مرحله‌ی بعد خواهد رفت.
\شروع{الگوریتم}{فیلتر ‌کتابخانه‌ها}
\ورودی کلاس هدف برای یافتن لیستی از کلاس‌های مشابه با آن $t_c$, لیستیی از کلاس‌های برنامک $S_{app}$

\خروجی لیستی از کلاس‌های کاندید برنامک مشابه با کلاس هدف $t_c$

\دستور قرار بده $Candidate = \emptyset$ 
\دستور قرار بده $L= length(Sig_{t_c})$  \توضیحات{مقدار$Sig(t_c)$ امضای نهایی کلاس $t_c$ می‌باشد}\\
\توضیحات{\مهم{فیلتر طولی کلاس‌های برنامک}}
\به‌ازای $Class \in S_{app}$ 
\اگر{$L-T_L < length(Sig_{Class}) < L + T_L$} 
\دستور{ $Candidate \cup  Class$}
\پایان‌اگر
\پایان‌به‌ازای\\
\توضیحات{\مهم{فیلتر ساختاری کلاس‌های برنامک}}
\به‌ازای $Class \in Candidate$ 
\دستور قرار بده $Condition = True$
\دستور قرار بده $Condition= Condition \wedge (\#outerClass(Class) = \#outerClass(t_c))$
\دستور قرار بده $Condition= Condition \wedge (\#InnerClass(Class) = \#InnerClass(t_c))$
\دستور قرار بده $Condition= Condition \wedge (DoesInherit(Class) = DoesInherit(t_c))$
\دستور قرار بده $Condition= Condition \wedge (SDKInherit(Class) = SDKInherit(t_c))$
\دستور قرار بده $Condition= Condition \wedge (\#Interfaces(Class) = \#Interfaces(t_c))$
\دستور قرار بده $Condition= Condition \wedge (SDKInterface(Class) = SDKInterface(t_c))$
\دستور قرار بده $Condition= Condition \wedge (OuterClass(Class) = OuterClass(t_c))$
\اگر{$Condition \neq True$}
\دستور$Condidate=Condidate - \{Class\}$
\پایان‌اگر
\پایان‌به‌ازای
\پایان{الگوریتم}

ماژول استخراج نگاشت، به جهت ایجاد نگاشتی میان کلاس‌های کتابخانه‌ای (خروجی ماژول پیداکردن کلاس‌های کاندید)‌ و کلاس‌های برنامک پیاده‌سازی شده‌است. ورودی ماژول لیست $Cls_{lib}$  شامل کلاس‌های کتابخانه‌ای برنامک، حاصل از اجرای الگوریتم ~\رجوع{الگوریتم: پیدا‌کردن کلاس‌های کاندید} و لیست $Cls_{app}$ کلاس‌های برنامک هدف می‌باشد. خروجی ماژول، نگاشتی یک به یک و پوشا از کلاس‌های کتابخانه‌ای به کلاس‌های برنامک می‌باشد و مشخص می‌کند کدام یک از کلاس‌های برنامک، کلاس‌های کتابخانه‌ای هستند. به عبارت دیگر، خروجی ماژول استخراج نگاشت، نگاشتی به صورت زیر می‌باشد:
  \begin{equation}
  	f: L \rightarrow A  \;\;\;\;\;\;\; L\subseteq Cls_{lib}  \;\;\; , A \subseteq Cls_{app}
  \end{equation}
در ابتدای این ماژول، کلاس‌های کتابخانه‌ای در سطح $i$ ام را با استفاده از متد $FilterClassByLevel$ محاسبه می‌کنیم و آن‌ را با $S_{lib,i}$ نمایش می‌دهیم. در ادامه به ازای تمامی کلاس‌های موجود در مجموعه‌ی کلاسی $S_{lib,i}$، کلاس‌های کاندید را با استفاده از ماژول یافتن کلاس‌های کاندید محاسبه و تحت عنوان $Candidate_{cls}$ ذخیره می‌کنیم.  سپس برای محاسبه‌ی کلاس‌های منطبق\پاورقی{Matched Classes} بر کلاس هدف، تمامی کلاس‌های کاندید حاصل از مرحله‌ی قبل را با استفاده از توابع چکیده‌سازی محلی، با کلاس هدف مقایسه و در صورتی که میزان تشابه دو کلاس از حد آستانه‌ی $Thr_{s}$ بیشتر بود آنگاه کلاس مورد نظر را به عنوان کلاس تطابق‌داده شده به مجموعه‌ی $Matched_{Class}$ اضافه می‌کنیم.  
 \شروع{الگوریتم}{پیدا‌کردن کلاس‌های کاندید}


 \ورودی لیست کلاس‌های برنامک $S_{app}$, مخزن کتابخانه‌های $libs$
 \خروجی لیست کتابخانه‌های استفاده‌شده در برنامک 

 
 \دستور قرار بده $Matched=\emptyset ,Libs = \emptyset$ 

 \به‌ازای $lib \in libs$ 
\دستور قرار بده $GetMaxLengthClasses‬‬(lib,N)‫‪ = TargetClasses$
\به‌ازای $Class \in TargetClasses$
\دستور قرار بده  $Candidates = FindCandidate(Class,S_{app}), Matched_{Class} = \emptyset$   

\به‌ازای $Ca \in Candidates$
\اگر{$FHashCompare(Sig_{ca}, Sig(Class)) > Thr_{F}$}
\دستور قرار بده $Matched_{Class} = Matched_{Class} \cup {Ca}$
\پایان‌اگر
\پایان‌به‌ازای
\دستور قرار بده $Matched = Matched \cup Matched_{class}$
\پایان‌به‌ازای
\اگر{$Matched \neq \emptyset$}
 
 \دستور قرار‌ بده $Libs = Libs \cup lib$
 \پایان‌اگر
\پایان‌به‌ازای\\
\برگردان $Libs$
 \پایان{الگوریتم}
در ادامه سعی می‌شود تا مسأله‌ی پیداکردن کلاس‌های کتابخانه‌ای را به مسأله‌ی تخصیص در یک گراف دوبخشی (حاصل از کلاس‌های کتابخانه‌ای و کلاس‌های برنامک) تبدیل کرد. به همین جهت گراف دو بخشی وزن‌دار  $G$ با تابع هزینه‌ی
 $C\times  ٰV \rightarrow \mathbb{N}$ 
 را با استفاده از کلاس‌های کتابخانه‌ای و کلاس‌های برنامک تشکیل می‌دهیم. گراف G به صورت زیر تعریف می‌شود:
   \begin{equation}
 	G = (U,V,E)
 \end{equation}
 مجموعه‌ی گره‌های $U$ شامل امضای کلاس‌های هدف کتابخانه‌ای در سطح $i$ ام است و گره‌های $V$ شامل تمامی کلاس‌ها‌ی تطابق‌یافته با کلاس هدف $cls$ می‌باشد. مجموعه یال‌های گراف  $E$، حاصل از ایجاد تطابق میان‌ کلاس‌های برنامک و کلاس‌های کتابخانه‌ای و $FhashCompare$ متد مقایسه‌ی امضای کلاسی با استفاده از چکیده‌سازی محلی می‌باشد. متد مقایسه به ازای ورودی امضای کلاس‌های مورد مقایسه، عددی بین ۰ و ۱۰۰ را بازمی‌گرداند.
\begin{equation}
 	U = \left \{ cls \:| cls \in S_{lib,i} \wedge Matched_{cls} \neq \emptyset \o   \right \}
\end{equation}
\begin{equation}
	V = \bigcup_{cls \in U}^{} Matched_{cls}
\end{equation}
\begin{equation}
E= \left \{ (cls,c)\; | cls \in \; s_{lib,i} \; , c \in Matched_{cls} \right \}
\end{equation}
\begin{equation}
	C(cls,c) = 100 - FhashCompare(Sig_{c} , Sig_{cls})
\end{equation}
\begin{equation}
	FhashCompare: Sig_{1} \times Sig_{2} \rightarrow R \;\;\;\;\; Sig_{1} , Sig_{2} \in ClassesSigs, \; 0 \leq R \leq 100
\end{equation}

\شروع{الگوریتم}{نگاشت کلاس‌های کتابخانه و برنامک}
\ورودی لیست کلاس‌های کتابخانه‌ای برنامک شامل $Cls_{lib}$ , لیست کلاس‌های برنامک شامل $Cls_{apps}$
\خروجی لیستی از دوتایی‌های $(LibraryClass,AppClass)$
\دستور قرار بده $f=\emptyset , i=\emptyset$
\تاوقتی{$Cls_{lib} \neq \emptyset$}
\دستور قرار بده $S_{lib,i} = FilterClassByLevel(S_{lib} , i)$
\دستور قرار بده $S_{lib} = S_{lib} - S_{lib,i}$
\دستور قرار بده $U = \emptyset , V = \emptyset , E = \emptyset$
\به‌ازای{$cls \in S_{lib,i}$}
\دستور قرار بده {$Candidate_{cls} = ‫‪FindCandidates‬‬(cls,Cls_{app})$}
\دستور قرار بده  $M_{cls} = \emptyset$
\به‌ازای $c \in Candidate_{cls}$
\اگر {$FhashCompare(Sig_{c} , Sig_{cls}) > Thr_{s}$}
\دستور قرار بده $Matched_{cls}= Matched_{cls} \cup {c}$
\دستور قرار بده $E = E \cup {(c,cls)}$
\پایان‌اگر
\پایان‌به‌ازای
\اگر {$M_{cls} \neq \emptyset$}
\دستور قرار بده $U = U \cup \{cls\}$
\دستور قرار بده $V = V \cup M_{cls}$
\پایان‌اگر
\پایان‌به‌ازای 
\دستور قرار بده {$f_{i} = ‫‪AssignmentSolver‬‬(U,V,E)$}
\دستور قرار بده $f = f \cup f_{i}$
\دستور قرار بده $i=i+1$
\پایان‌تاوقتی\\
\برگردان $f$
\پایان{الگوریتم}
گراف G یک گراف دو بخشی حاصل از گره‌های $U$ و $V$ می‌باشد که توسط مجموعه‌ یال‌های $E$ به یکدیگر متصل شده‌اند. برای نگاشت گره‌های مجموعه‌ی  $V$ به مجموعه‌ی $U$ از حل مسئله‌ی تخصیص برای سطح $i$، در گراف $G$ استفاده شده‌است.  خروجی ماژول نگاشت کتابخانه‌ها، تابع یک‌به‌یک و پوشا‌ خواهد بود. در نهایت اجتماع توابع یک‌به‌یک و پوشای به‌دست آمده به ازای هر یک از کلاس‌های کتابخانه‌ای، خروجی ماژول نگاشت می‌باشد که همان نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک می‌باشد. شبه‌کد رویه‌ی  نگاشت میان کلاس‌های کتابخانه‌ای و کلاس‌های برنامک را می‌توان در الگوریتم ~\رجوع{الگوریتم: نگاشت کلاس‌های کتابخانه و برنامک} مشاهده نمود.

\زیرقسمت{مؤلفه‌ی یافتن نزدیک‌ترین همسایه}
جهت افزایش سرعت تشخیص برنامک‌های بازبسته‌بندی شده، از یک مرحله‌ی پیش‌پردازش شامل الگوریتم $k$ نزدیک‌ترین همسایه\پاورقی{K-Nearest Neighbors} استفاده شده‌است. همانطور که در شکل ~\رجوع{شکل:کی‌ان‌ان} مشاهده می‌شود به جهت اجرای الگوریتم نزدیک‌ترین همسایه، ابتدا ۵ ویژگی، مبتنی بر منابع برنامک با استفاده از ماژول استخراج ویژگی‌، با استفاده از الگوریتم ~\رجوع{الگوریتم: استخراج ویژگی‌های مبتنی بر منابع} استخراج می‌شود و درخت ۵ بعدی حاصل از اجرای الگوریتم ~\رجوع{الگوریتم: ساخت درخت دو‌بعدی جست‌و‌جوی $K$ نزدیک‌ترین همسایه} ساخته می‌شود. در نهایت با استفاده از اجرای رویه‌ی یافتن نزدیک‌ترین همسایه‌ی‌ در الگوریتم ~\رجوع{الگوریتم: جست‌و‌جوی $K$ نزدیک‌ترین همسایه}، برنامک‌های کاندید جهت مقایسه‌ی دودویی را انتخاب می‌کنیم.
\شروع{شکل}[H]
\centerimg{kdknn}{16cm}
\vspace{1em}
\شرح{نمای کلی مؤلفه‌ی یافتن‌ نزدیک‌ترین همسایه}
\برچسب{شکل:کی‌ان‌ان}
\پایان{شکل}

\زیرزیرقسمت{انتخاب ویژگی}
به جهت اجرای فرایند یافتن نزدیک‌ترین همسایه‌های هر برنامک، نیازمند مجموعه‌ای از ویژگی‌های هر برنامک هستیم که مقاومت بالایی مقابل راهکار‌های مبهم‌نگاری داشته‌باشد. از آنجا که در قسمت مقایسه‌ی دودویی و تشکیل امضای برنامک‌، بیشتر از ویژگی‌های مبتنی بر کد برنامک‌های اندرویدی استفاده شده‌است، در این قسمت برای تمایز بهتر برنامک‌ها از ویژگی‌های مبتنی بر منابع برنامک که واسط کاربری آن‌را تشکیل می‌دهد استفاده کرده‌ایم. در ادامه به بررسی و توضیح دلیل انتخاب هر کدام از ویژگی‌های استخراج‌شده در این قسمت می‌پردازیم.
\شروع{فقرات}
\فقره{\مهم{تعداد فعالیت‌ها}}: هر فعالیت\پاورقی{Activity} یک صفحه‌ی جداگانه را در برنامک‌های اندرویدی به منظور پیاده‌سازی واسط‌ کاربری در اختیار توسعه‌دهندگان قرار می‌دهد. از آن‌جایی که پیاده‌سازی فعالیت‌های جدید، نیازمند افزودن آن‌ها در حلقه‌ی فراخوانی فعالیت‌هاست، بنابر‌این، برنامک‌های بازبسته‌بندی شده عموماً دارای تعداد فعالیت مشخص و مشابه هستند چرا که بخشی از اهداف آن‌ها در صورتی محقق می‌شود که کاربران به جهت شباهت‌های واسط کاربری دچار خطا شوند. برای استخراج فعالیت‌های هر برنامک، از فایل $AndroidManifest.xml$ استفاده شده‌است. همانطور که در الگوریتم ۴ مشاهده می‌شود، فعالیت‌های اندرویدی در فایل $AndroidManifest.xml$ با تگ مشخص $Activity$ مشخص شده‌اند. نمونه‌ای از تعریف   یک فعالیت در تصویر ~\رجوع{شکل:فعالیت} مشاهده می‌شود.
\پایان{فقرات}
\شروع{شکل}[H]
\centerimg{Activity}{12cm}
\vspace{1em}

\شرح{نمونه‌ای از ‌تعریف یک فعالیت}
\برچسب{شکل:فعالیت}
\پایان{شکل}

\شروع{فقرات}
\فقره{\مهم{تعداد مجوز‌های دسترسی برنامک}}: ویژگی دیگری که برای طبقه‌بندی از آن استفاده شده‌است، تعداد مجوز‌های دسترسی\پاورقی{permissions} هر برنامک است که در طی اجرای برنامک از کاربر درخواست می‌شود. از آن‌جایی که اجرای بدافزار‌های بازبسته‌بندی شده، نیازمند دسترسی‌های گوناگون‌ است بنابراین بدافزارنویسان برای اهداف خود از مجوز‌های دسترسی به کرات استفاده می‌کنند. همانند تعداد‌ فعالیت‌های برنامک، برای شمارش تعداد مجوز‌های دسترسی، نیازمند شمارش تگ مخصوص $uses-permission$ در فایل فراداده‌ی\پاورقی{Meta-Data} $AndroidManifest.xml$ هستیم. نمونه‌ای از تعریف حق‌دسترسی جهت استفاده از دوربین کاربر را در تصویر ~\رجوع{شکل:دسترسی} مشاهده می‌کنید.


\پایان{فقرات}
\شروع{شکل}[H]
\centerimg{premessions}{12cm}
\vspace{1em}
\شرح{نمونه‌ای از ‌تعریف یک حق‌دسترسی}
\برچسب{شکل:دسترسی}
\پایان{شکل}

\شروع{فقرات}
\فقره{\مهم{تعداد فیلتر‌های تصمیم}}: جابه‌جایی میان صفحات برنامک و یا جابه‌جایی میان صفحات برنامک‌های اندرویدی، با استفاده از فیلتر‌های تصمیم\پاورقی{Intent Filters} صورت می‌گیرد. با استفاده از فیلتر‌های تصمیم برنامک مولفه‌ی\پاورقی{Component} درخواستی خود را به سیستم‌عامل اعلام می‌کند. بنابراین رفتار برنامک‌های اندرویدی، از جهتی مبتنی بر فیلتر‌های تصمیم هستند چرا که عمده‌ی فعالیت‌های یک برنامک مبتنی بر جابه‌جایی میان صفحات مختلف (فعالیت‌ها) با استفاده از فیلتر‌های تصمیم می‌باشد. در این قسمت تمامی فیلتر‌های تصمیم ضمنی و یا صریح، با استفاده از فایل $AndroidManifest.xml$ و تگ مخصوص $intent-filter$ استخراج می‌شود.

\فقره{\مهم{ میانگین تعداد فایل‌های $\textbf{png}$}}: برای محاسبه‌ی میانگین تعداد فایل‌های تصویری که پسوند $png$ دارند، از شمارش تعداد پوشه‌های $drawable$ که حاوی تصاویر برنامک هستند استفاده شده‌است. منظور از میانگین در این ویژگی، محاسبه‌ی تقسیم تعداد تمامی فایل‌های $png$ بر تعداد پوشه‌های $drawable$ می‌باشد.

\فقره{\مهم{ میانگین تعداد فایل‌های $\textbf{xml}$}}:  همانطور که در الگوریتم ۴ مشاهده می‌شود، برای محاسبه‌ی میانگین تعداد فایل‌های با پسوند $xml$ از محاسبه‌ی تعداد پوشه‌های موجود در پوشه‌ی منابع برنامک یعنی $/res$ استفاده شده‌است. از آن‌جایی که عناصر موجود در واسط‌کاربری برنامک توسط فایل‌های $xml$ پیاده‌سازی می‌شود، بنابراین حذف و یا اضافه‌کردن آن‌ها نیازمند صرف هزینه می‌باشد. دلیل اسفاده از میانگین در دو ویژگی اخیر، ناشی از عدم تغییر این عدد به ازای اضافه کردن پوشه‌های جدید است. برای مثال در صورتی که یک برنامک با استفاده از یک زبان دوم بازبسته‌بندی شود، یک پوشه‌ شامل منابع آن ایجاد می‌شود. حال در این صورت تعداد کل منابع $xml$ اضافه شده‌است اما میانگین آن‌ها تغییر چندانی نمی‌کند.
\پایان{فقرات}


\شروع{الگوریتم}{استخراج ویژگی‌های مبتنی بر منابع}
\ورودی برنامک‌های موجود در مخزن $DsApps$ و فایل فراداده‌ی هرکدام‌ $Manifest_{app}$
\خروجی ویژگی‌های ۵ تایی از هر برنامک شامل مجموعه‌ی $Features$
\دستور قرار بده $Features=\emptyset$
\به‌ازای{$app \in  DsApps$} 
\به‌ازای{$tag \in Manifest_{app}$}
\اگر $tag=Activity$
\دستور قرار بده $Features_{app,AcNumber} =Features_{app,AcNumber} + 1 $
\پایان‌اگر
\اگر $tag=uses-premession$
\دستور قرار بده $Features_{app,PNumber} =Features_{app,PNumber} + 1 $
\پایان‌اگر
\اگر $tag=intent-filter$
\دستور قرار بده $Features_{app,IfNumber} =Features_{app,IfNumber} + 1 $
\پایان‌اگر
\دستور قرار‌بده $\#TotalDrawableDir = GetTotalDrNum()$
\دستور قرار بده $\#TotalPngFiles = GetTotalPngs("/res")$
\دستور قرار بده $Features_{app,AvgPngPerDir}=  \frac{\#TotalPngFiles}{\#GetTotalDrNum}$

\دستور قرار‌بده $\#TotalResDir = GetTotalDirNum()$
\دستور قرار بده $\#TotalXmlFiles = GetTotalXmls("/res")$
\دستور قرار بده $Features_{app,AvgXmlPerDir}=  \frac{\#TotalXmlFiles}{\#GetTotalDirNum}$
\پایان‌به‌ازای
\پایان‌به‌ازای\\
\برگردان $Features$
\پایان{الگوریتم}
پس از جمع‌آوری ویژگی‌های ذکر‌شده، با فرض آن‌که $ \vartheta =\{\alpha^i | i \in [1..N]\}$
مجموعه‌ی برنامک‌های موجود در مخزن‌ باشد، بردار ویژگی هر برنامک را با 
$Features_{i} =(f^{i}_{1},...,f^{i}_{5})$
که به ترتیب شامل  تعداد فعالیت‌ها، تعداد دسترسی‌های درخواستی، تعداد فیلتر‌های تصمیم، میانگین تعداد فایل‌های $xml$ و میانگین تعداد فایل‌های $png$ نشان می‌دهیم. پس از ایجاد بردار ویژگی $Features_{i}$، به منظور هم‌سانی‌ داده‌های آزمون، نرمال‌سازی با استفاده از تابع $Normalized$ روی داده‌ها صورت می‌گیرد. معادله‌ی تابع $Normalized$ به ازای هر ویژگی $f^{i}_{j}$ زیر مشخص‌ می‌شود.\\
\begin{equation}
Normalized(f^{i}_{j})=\sqrt{\frac{f^{i}_{j}-min(f^{1,..,N}_{j})}{max(f^{1,..,N}_{j})-min(f^{1,..,N}_{j})}}
\end{equation}

ماژول اسخراج ویژگی‌های مبتنی بر منابع به عنوان ورودی برنامک‌های موجود در مخزن و فایل فراداده‌ی $AndroidManifest.xml$ و به عنوان خروجی، لیستی از ویژگی‌های ۵ تایی ذکرشده برای هر برنامک بازمی‌گرداند.
\زیرزیرقسمت{ساخت درخت $KD$}
در ادامه برای طبقه‌بندی داده‌های هر برنامک از یک طبقه‌بند مبتنی بر نزدیک‌ترین همسایه‌ استفاده ‌شده‌است. به صورت کلی دو روش پیاده‌سازی برای جست‌و‌جوی نزدیک‌ترین همسایه وجود دارد. در بدیهی‌ترین حالت ابتدا فاصله‌ی یک نقطه از تمامی نقاط‌ دیگر را محاسبه، در ادامه با استفاده از مرتب‌سازی مبتنی بر فاصله، تعدادی از نزدیک‌ترین همسایه‌ها را استخراج می‌کنیم. همانطور که مشخص‌است روش مورد نظر نیازمند محاسبه‌ی فاصله‌ی نقطه‌ی ورودی با تمامی نقاط دیگر ‌است. در روش دیگری که به $KD\text{-}KNN$ شهرت دارد، ابتدا تمامی داده‌های برنامک را در یک داده‌ساختار\پاورقی{Data Structure} درختی ذخیره و برای جست‌و‌جوی $K$ تا از نزدیک‌ترین همسایه‌های هر گره، از آن استفاده می‌کنیم. در این ساختار درختی برای جست‌و‌جوی گره‌های نزدیک، تمامی داده‌های آزمون به بلوک‌های نزدیک به هم تقسیم و پردازش گره‌های نزدیک‌ تنها در این بلاک صورت می‌گیرد. در ادامه برای درک بهتر الگوریتم جست‌و‌جوی درختی $KNN$ مثالی از یک مجموعه‌ داده‌ی آزمون دو بعدی را در الگوریتم ~\رجوع{الگوریتم: ساخت درخت دو‌بعدی جست‌و‌جوی $K$ نزدیک‌ترین همسایه} بررسی خواهیم کرد. 

پس از اجرای الگوریتم ابتدا نقاط ورودی بر اساس عنصر اول دوتایی‌های ورودی جداسازی و مرتب‌ می‌شوند.در ادامه میانه‌ی\پاورقی{Median} داده‌‌های مرتب‌شده‌ی حاصل از مرحله‌ی قبل، محاسبه و عناصر داده‌ای بیش از مقدار میانه در سمت راست درخت و عناصر کم‌تر در سمت چپ درخت تقسیم می‌شوند. این مرحله‌، در واقع سازو‌کار ایجاد بلوک‌های داده‌ای انجام می‌شود. از آن‌جایی که فاصله‌ی دو نقطه در فضا از یکدیگر با استفاده از معادله‌ی ~\رجوع{eq:1} محاسبه می‌شود، بنابراین جداسازی بلوک‌های داده‌ای در الگوریتم ~\رجوع{الگوریتم: ساخت درخت دو‌بعدی جست‌و‌جوی $K$ نزدیک‌ترین همسایه} به صورت یکی در میان، بر اساس عناصر اول و دوم از لیست داده‌ای تقسیم می‌شوند.
\begin{equation}
	d(x,y)=\sqrt{(x_{2}-x_{1})^2 + (y_{2}-y_{1})^2} \label{eq:1}
\end{equation}

برای ساخت درخت مبتنی بر ویژگی‌های استخراج‌شده از الگوریتم ~\رجوع{الگوریتم: استخراج ویژگی‌های مبتنی بر منابع}، از بردار ویژگی حاصل استفاده کرده و در نهایت درخت ۵ بعدی حاوی اطلاعات برنامک‌های اندرویدی ساخته می‌شود. هر گره درخت مذکور حاوی یک بردار ویژگی ۵ تایی است و مطابق الگوریتم ~\رجوع{الگوریتم: ساخت درخت دو‌بعدی جست‌و‌جوی $K$ نزدیک‌ترین همسایه} تصمیم‌گیری در مورد تقسیم داده‌های موجود در هر سطح با توجه به یکی از عناصر ۵ تایی صورت می‌گیرد. به عنوان مثال، زمانی که در سطح اول و ریشه‌ی درخت هستیم، عناصر اول ۵‌تایی‌های مجموعه‌داده را جدا و آن‌ها را مرتب می‌کنیم. سپس با توجه به محاسبه‌ی میانه مقدار $Median$ را برای این گروه داده‌ای محاسبه کرده و ۵ تایی مربوط به عنصر $Median$ در ریشه قرار می‌گیرد. سپس باقی مجموعه‌ی داده‌ای با توجه به بزرگ‌تر بودن و یا کوچک‌تر بودن از عنصر  $axis$ که همان شاخص تصمیم است، تقسیم می‌شوند و این رویه به صورت بازگشتی برای تمامی بلوک‌های داده‌ای و گره‌های درخت تکرار می‌شود تا زمانی که درخت ساخته شود.

ماژول ساخت درخت $KD$ در این پژوهش لیستی از عناصر ۵ تایی حاوی ویژگی‌های مبتنی بر منابع و به طول $n$ می‌باشد. خروجی ماژول یک درخت ۵ بعدی حاوی ویژگی‌های مذکور است که می‌توان رویه‌ی جست‌و‌جوی نزدیک‌ترین همسایه‌ مطابق الگوریتم ~\رجوع{الگوریتم: جست‌و‌جوی $K$ نزدیک‌ترین همسایه} را از مرتبه‌ی ${log(n)}$ اجرا کرد. 
\شروع{الگوریتم}{ساخت درخت دو‌بعدی جست‌و‌جوی $K$ نزدیک‌ترین همسایه}
\ورودی لیستی از داده‌های دوتایی $Points$ به صورت $(x,y)$ و به طول $n$ 
\ورودی عمق سطح $Depth$
\خروجی درخت دو‌بعدی شامل داده‌های ورودی
\دستور قرار بده 
$Dimension=Depth \mod 2$
\اگر $Dimension=1$
\دستور قرار بده $Median=GetMedian(Sort(x_{1},....,x_{n}))$
\وگرنه
\دستور قرار‌ بده
$Median=GetMedian(Sort(y_{1},....,y_{n}))$
\پایان‌اگر
\دستور قرار بده $Node.data=Median$
\دستور قرار بده $Node.axis=Dimension$
\دستور قرار بده
$Node.leftChild = kdtree(points \:\:\: in \:\:\: points \:\:\: before \:\:\: median, depth+1)$
\دستور قرار بده
$Node.rightChild = kdtree(points \:\:\: in \:\:\: points \:\:\: after \:\:\: median, depth+1)$
\پایان{الگوریتم}
\زیرزیرقسمت{جست‌و‌جوی $k$ همسایه‌ی نزدیک}
پس از ساخت داده‌ساختار درختی پنج‌بعدی در مرحله‌ی قبل، حال هدف یافتن نزدیک‌ترین همسایه‌های هر برنامک به جهت بررسی دوتایی‌ آن‌ها می‌باشد. به همین جهت در این قسمت از الگوریتم جست‌و‌جوی نزدیک‌ترین همسایه که در پژوهش \مرجع{8690508}  معرفی شده‌است، استفاده کرده‌ایم. شبه‌کد این رویه را می‌توان در الگوریتم ~\رجوع{الگوریتم: جست‌و‌جوی نزدیک‌ترین همسایه} مشاهده نمود.\\
\شروع{الگوریتم}{جست‌و‌جوی نزدیک‌ترین همسایه}
\ورودی ریشه‌ی درخت $Root$ 
\ورودی نقطه‌ی آزمون $TPoint$
\خروجی نزدیک‌ترین نقطه به ورودی $NearestPoint$
\دستور قرار‌ بده $Path=\emptyset$
\تاوقتی{$ًRoot!=leaf$}
\دستور $Path.add(Root)$
\اگر{$Root[data][Root.axis] > TPoint[axis]$}
\دستور $Searchtree(rightChild)$
\وگرنه
\دستور $Searchtree(leftChild)$
\پایان‌اگر
\پایان‌تاوقتی
\به‌ازای{$Point \in Path$}
\دستور قرار‌بده 
$NearestDist=Distance(Point,TPoint)$
\اگر{$|Point[Data][axis]-TPoint[axis]|>|TPoint[axis]-Root[Data][axis]|$}
\دستور $Travel(Root.nextchild)$
\دستور قرار بده 
$Dist=Distance(ChildPoint,TPoint)$
\اگر{$Dist > NearestDist$}
\دستور قرار بده $NearestDist=Dist$
\دستور قرار بده $NPoint=Point$
\پایان‌اگر
\پایان‌اگر
\پایان‌به‌ازای
\دستور قرار بده $NearestPoint=NPoint$\\
\برگردان  $NearestPoint$
\پایان{الگوریتم}

ورودی الگوریتم شامل ریشه‌ی درخت $KD$ و هدف آن‌ یافتن نزدیک‌ترین نقطه از میان نقاط درون درخت به نقطه‌ی ورودی $Tpoint$ می‌باشد. به طور کلی الگوریتم مذکور را می‌توان به دو قسمت تقسیم کرد، در قسمت اول در طی یک روند رو به جلو سعی می‌کنیم با توجه به نقطه‌ی ورودی، مکان درست آن را در برگ درخت بیابیم. به همین منظور از یک ساختار مبتنی بر درخت تصمیم\پاورقی{Decision Tree} استفاده می‌کنیم. در این ساختار، در صورتی که  مقدار شاخص تصمیم\پاورقی{Decision Index} $axis$ بردار ورودی، از همین مقدار در بردار گره بیشتر باشد، آن‌گاه جست‌و‌جو را در زیر‌درخت سمت راست ریشه انجام می‌دهیم و در صورتی که مقدار آن کوچکتر باشد آن‌گاه زیر درخت سمت چپ را بررسی می‌کنیم. این روند بازگشتی را تا زمانی که به گره برگ برسیم ادامه می‌دهیم و مسیر طی‌شده را ذخیره می‌کنیم. در مرحله‌ی بعدی با توجه به نقاط درون مسیر $Path$ تمامی گره‌های مسیر‌ را به صورت عقب‌گرد\پاورقی{Back Track} بررسی و نزدیک‌ترین بردار ویژگی\پاورقی{Feature Vector} به گره ورودی را پیدا کرده و آن را بازمی‌گردانیم.
متد $Distance$ در الگوریتم ~\رجوع{الگوریتم: جست‌و‌جوی نزدیک‌ترین همسایه} فاصله‌ی میان دو بردار ۵ تایی را با استفاده از فاصله‌ی اقلیدوسی به صورت زیر محاسبه می‌کند.
\begin{equation}
	d(f^1,f^2) = \sqrt{(f^1_{1}-f^2_{1})^2 + (f^1_{2}-f^2_{2})^2  + ... +(f^1_{5}-f^2_{5})^2  }
\end{equation}

پس از ایجاد درخت و پیاده‌سازی الگوریتم نزدیک‌ترین همسایه، تعداد $K $فراخوانی از الگوریتم ~\رجوع{الگوریتم: جست‌و‌جوی نزدیک‌ترین همسایه} منجر به دریافت لیستی از $K $ نزدیک‌ترین همسایه‌های بردار ورودی می‌شود

\زیرقسمت{مقایسه‌ی دودویی و تشخیص برنامک‌های بازبسته‌بندی شده}
هدف از پیاده‌سازی مرحله‌ی  طبقه‌بندی، کاهش فضای مقایسه‌ی دودویی در این مرحله بوده‌است که منجر به افزایش سرعت مقایسه می‌شود. پس از اجرای الگوریتم یافتن $K$ تا از نزدیک‌ترین همسایه‌های برنامک ورودی با استفاده از ویژگی‌های مبتنی بر منبع، در این قسمت مقایسه‌ی دودویی میان $K$ برنامک و برنامک ورودی صورت می‌گیرد.\\ 
پس از شناسایی کلاس‌های کتابخانه‌ای در الگوریتم ~\رجوع{الگوریتم: نگاشت کلاس‌های کتابخانه و برنامک}، نگاشتی از کلاس‌های هر برنامک داخل مخزن و برنامک هدف با کلاس‌های کتابخانه‌ای به صورت $F:LibraryClasses\rightarrow AppClasses$ به دست می‌آید. در ادامه امضای هر کدام از کلاس‌های برنامک را تشکیل می‌دهیم. امضای هر برنامک از الحاق تمامی امضای کلاس‌های آن ایجاد می‌شود. سپس شروع به حذف کلاس‌های کتابخانه‌ای با توجه به نگاشت $F$ از هر برنامک می‌کنیم و مجموعه‌ی کلاس‌های برنامک با حذف کتابخانه‌های اندرویدی تشکیل مجموعه‌ی $S^{'}_{app}$ را می‌دهند که به صورت زیر محاسبه شده‌است.  $AppClasses$ مجموعه‌ی تمامی کلاس‌های کتابخانه‌ای است که در نگاشت $F$ به دست آمده‌است.
\begin{equation}
	Cls^{'}_{app} = Cls_{app} - AppClasses
\end{equation}




پس از حذف کلاس‌های کتابخانه‌ای از هر امضا، در این مرحله امضای اصلی برنامک حاوی کلاس‌هایی که توسط توسعه‌دهنده پیاده‌سازی شده‌اند را با یکدیگر مقایسه می‌کنیم. مقایسه‌ی امضای برنامک‌ها با استفاده از روش‌های چکیده‌سازی محلی صورت می‌گیرد. استفاده از روش‌های چکیده‌سازی معمولی، نظیر $MD5$ برای تشابه‌سنجی، منجر به افزایش خطا در صورت مبهم‌نگاری برنامک‌ها خواهد شد چرا که روش‌های معمول عموماً ‌برای تولید شناسه‌ی یکتا\پاورقی{Unique} کاربرد دارند و در صورتی که قسمت کوچکی از ورودی آن‌ها تغییر کند، آنگاه چکیده‌ی جدید حاصل از این توابع، به صورت کامل متفاوت خواهد بود. بنابراین استفاده از این روش‌ها برای شباهت‌سنجی میان امضای برنامک‌های اندرویدی پیشنهاد نمی‌شود. به همین منظور، در شباهت‌سنجی میان فایل‌های متنی و یا به جهت تشخیص تکرار ساختار‌های واحد در فایل‌های مشابه، از روش‌های مبتنی بر چکیده‌سازی محلی استفاده می‌شود. ساختار کلی این روش‌ها، استفاده از تشابه میان بلوک‌های تکراری در متون می‌باشد و به همین دلیل، اگر دو فایل مشابه به عنوان ورودی به آن‌ها داده‌شود، آنگاه چکیده‌ی نهایی نیز به همان میزان مشابه خواهد بود. در صورتی که میزان تشابه میان امضای نهایی برنامک‌های موجود در مخزن از یک حد آستانه مانند $Thr_c$ کم‌تر باشد، آن‌گاه دو برنامک مورد نظر بازبسته‌بندی شده تشخیص داده می‌شوند.














