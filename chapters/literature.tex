\فصل{تعریف مسأله و مرور کار‌های پیشین}
\label{literature}
پژوهش‌های اخیر در حوزه‌ی تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده نشان می‌دهد که تشخیص این دسته از برنامک ها تحت تاثیر دو عامل مبهم‌نگاری و جداسازی صحیح کتابخانه‌های اندرویدی قرار دارد. برخی از پژوهش‌های اخیر انجام‌شده در این حوزه، تشخیص کتاب‌خانه‌های بسته‌ی تقلبی را با فرض عدم مبهم‌نگاری کتابخانه‌ها انجام داده‌اند که مشخصاً این فرضی نادرست است چرا که بسیاری از مبهم‌نگار‌های ابتدایی نیز این کار را در کتابخانه‌های اندرویدی انجام می‌دهند. در اکثر روش‌های پیشنهادی قسمتی از روش، مختص تشخیص و جداسازی کتابخانه‌های اندرویدی‌ است. شناسایی کد‌های کتابخانه‌ای از آن‌جهت اهمیت دارد که تشخیص درست آن‌ها می‌تواند خطای مثبت غلط و منفی غلط را کاهش دهد. در بیشتر مواقع، خصوصا در ابزار‌های مبهم‌نگاری، متقلب هنگام بازبسته‌بندی اقدام به مبهم‌نگاری در کتابخانه‌های اندرویدی می‌کند و بدین صورت سعی در افزایش منفی غلط در ابزار‌های تشخیص دارد. در صورتی که کد‌های کتابخانه‌ای به درستی تشخیص و جداسازی نشوند، شباهت‌های موجود میان برنامک‌های مورد بررسی، خصوصا در روش‌های مبتنی بر تحلیل ایستا،‌ ناشی از کد‌های کتابخانه‌ای خواهد بود. از سوی دیگر، تشخیص مبهم‌نگاری در کد‌های مورد توسعه توسط متقلب، نیازمند ویژگی‌هایی از برنامک مورد نظر است که مقاومت بالایی در برابر مبهم‌نگاری داشته‌ باشند. بدین معنا که متقلب برای تغییر این دسته ازویژگی‌ها ناچار به پرداخت هزینه‌ی زمانی و فنی باشد و در نهایت از تغییر این دست از ویژگی‌ها، پرهیز کند. در بسیاری از روش‌های ارائه‌شده در سال‌های اخیر، تشخیص برنامک‌های بازبسته‌بندی شده مبتنی بر ویژگی‌هایی صورت گرفته‌ است که در عین مقاومت در مقابل مبهم‌نگاری، هزینه‌ی محاسباتی تشخیص برنامک‌های بازبسته‌بندی شده را افزایش می‌د‌هد به طوری که استفاده از این روش‌ها را عملا در یک محیط صنعتی غیر ممکن ساخته‌است. 

با توجه به اهمیت تشخیص مبهم‌نگاری و در نهایت تشخیص برنامک‌های بازبسته‌بندی شده و همچنین، در نظر گرفتن سرعت تشخیص به عنوان یک عامل مهم، در این فصل به بررسی و مرور کار‌هایی می‌پردازیم که روش‌های گوناگونی را برای تشخیص برنامک‌های بازبسته‌بندی استفاده کرده‌اند و مزایا و معایب هر کدام را به صورت جدا بررسی خواهیم‌کرد. از آن‌جایی که هدف این پژوهش بهبود کارایی روش‌های تشخیص برنامک‌های بازبسته‌بندی شده‌است و تمرکز پژوهش بر روی تشخیص کد‌های کتابخانه‌ای نبوده‌است، در ابتدا روند کلی تشخیص برنامک‌های بازبسته‌بندی‌ شده را در پژوهش‌های مرتبط بیان کرده و به اختصار، روش‌های جداسازی کتابخانه‌های اندرویدی از کد‌های مورد توسعه را توضیح می‌دهیم و از مرور کار‌های پیشین انجام‌شده در این حوزه عبور خواهیم کرد.

در ادامه ابتدا به روند کلی تشخیص برنامک‌های بازبسته‌بندی شده می‌پردازیم و مسئله‌ی تشخیص برنامک‌های بازبسته‌بندی شده را از دیدگاه این پژوهش، شرح می‌دهیم. همچنین، دسته‌بندی انواع روش‌های تشخیص را با توجه به پژوهش‌های سال‌های اخیر بیان‌ می‌کنیم و از هر دسته، چند پژوهش انجام‌شده را بررسی خواهیم کرد. برای درک بهتر روش‌ پیشنهادی، در هر قسمت به بیان مزایا و معایب هر روش خواهیم پرداخت و علاوه بر این روش تشخیص کد‌های ‌کتابخانه‌ای در هر پژوهش را مشخص خواهیم‌کرد.


\قسمت{تعریف مسئله}
علی‌رغم پژوهش‌های متعدد صورت‌گرفته در این زمینه، همانند تعریف بازبسته‌بندی، هنوز تعریف مشخصی نیز برای تشخیص بازبسته‌بندی ارائه‌نشده‌ است. پژوهش‌های سال‌های اخیر در حالت کلی تشخیص بازبسته‌بندی را به دو صورت تعریف می‌کنند:‌



\شروع{تعریف}[تشخیص بازبسته‌بندی مبتنی بر برنامک مبدا]
ا\label{tarif1} تشخیص بسته‌ی بازبسته‌بندی شده، یعنی تشخیص جفتی از برنامک‌های درون مخزن که دقیقا جفت مشابه برنامک ورودی باشد. به بیان دیگر در این تعریف مشخص می‌شود که برنامک ورودی بازبسته‌بندی شده است یا خیر و در صورتی که بود، جفت برنامک آن درون مخزن نیز مشخص می‌شود.
\پایان{تعریف}
\شروع{تعریف}[تشخیص بازبسته‌بندی مبتنی بر تصمیم‌گیری برنامک مقصد]
\label{tarif2} تشخیص بسته‌ی بازبسته‌بندی شده، یعنی مشخص کنیم برنامک ورودی بازبسته‌بندی شده است یا خیر. در این حالت تشخیص برنامک اصلی اهمیتی ندارد و مسئله، تصمیم‌گیری \پاورقی{Decision} درباره‌ی بازبسته‌بندی بودن یک برنامک ورودی است.
\پایان{تعریف}






در سال‌های اخیر، اکثر پژوهش‌ها از یکی از تعاریف بالا برای تشخیص بازبسته‌بندی استفاده کرده‌اند. برای پاسخ به تعریف ۲، پژوهش‌هایی نظیر \مرجع{Alswaina2020, sym14040718, Chen_2020} از روش‌های مبتنی بر مدل‌های یادگیری ماشین\پاورقی{Machine Learning} برای تشخیص برنامک‌های بازبسته‌‌بندی شده استفاده کرده‌اند. حال آن‌که پژوهش‌های مرتبط با تعریف ۱، نظیر \مرجع{inproceedings,Sun2016}  بیشتر از روش‌های مقایسه‌ی دودویی و مبتنی بر شباهت‌سنجی استفاده کرده‌اند. 

تعریفی که در این پژوهش مورد استفاده قرار‌گرفته‌ است، تعریف ۱ است. یعنی تشخیص بازبسته‌بندی منوط به \مهم{تشخیص جفت برنامک اصلی }در مخزن برنامک‌های موجود می‌باشد. بنابراین در طی فرایند تشخیص به دو سوال اساسی پاسخ می‌دهیم:‌

\شروع{فقرات}
\فقره آیا برنامک ورودی بازبسته‌بندی شده‌ی یک برنامه‌ی دیگر است؟‌
\فقره در صورتی که برنامک مورد بررسی، بازبسته‌بندی شده‌ی برنامک دیگری بود، آن‌گاه جفت بازبسته‌بندی شده‌ی برنامک ورودی کدام برنامک است.
\پایان{فقرات}


\قسمت{روند کلی تشخیص برنامک‌های بازبسته‌بندی شده}
با بررسی پژوهش‌های صورت‌گرفته در حوزه‌ی تشخیص برنامک‌های بازبسته‌بندی شده، درمی‌یابیم که به طور مشخص عمده‌ی این روش‌ها مراحل مشابهی را برای حل این مسئله، دنبال کرده‌اند. به طور کلی عمده‌ی روش‌های تشخیص، به عنوان ورودی، یک برنامک اندویدی شامل یک فایل با پسوند $apk$ را دریافت کرده و پس از گذر از سه مرحله، مسئله را حل می‌کنند. در ادامه به بررسی این سه مرحله می‌پردازیم.

\زیرقسمت{پیش‌پردازش برنامک‌های اندرویدی}

یکی از مراحل مهم در تشخیص برنامک‌های بازبسته‌بندی شده، مرحله‌ی پیش‌پردازش\پاورقی{Pre process}  است که تاثیر به سزایی در سرعت و دقت روش تشخیص خواهد داشت. حذف کد‌های کتابخانه‌ای ، حذف کد‌های مرده و یا بیهوده و اعمال فیلتر‌های ساختاری\پاورقی{Structural} از موارد نمونه در قسمت پیش‌پردازش است. در این قسمت روش‌های کلی مورد استفاده توسط پژوهش‌های اخیر جهت حذف کد‌های کتابخانه‌ای را توضیح می‌دهیم. با توجه به مرور کار‌های پیشین انجام‌شده در این حوزه، به صورت کلی دو دیدگاه در مورد تشخیص و جداسازی کتابخانه‌های اندرویدی وجود دارد:

\شروع{فقرات}
\فقره \مهم{مبتنی بر لیست سفید:} در این روش، لیستی از نام بسته‌های مشهور کتابخانه‌ای در برنامک‌های اندرویدی در دسترس است و با استفاده از نام بسته‌های موجود در برنامک، کد‌های کتابخانه‌ای از کد‌های مورد توسعه جدا می‌شوند. راه‌ حل‌های مبتنی بر این روش، عموماً در مقابل مبهم‌نگاری‌های ساده‌ای نظیر تغییر نام بسته نیز مقاوم نیستند و به راحتی می‌توان آن‌ها را دور زد. مزیت این روش آن‌است که سرعت بالایی دارد چرا که فقط نام بسته‌ها با یکدیگر مقایسه می‌شوند اما دقت خوبی را ارائه نمی‌دهند.غالب پژوهش‌های مبتنی بر استفاده از لیست سفید، فرض کرده‌اند که تنها کد‌های مورد توسعه توسط متقلب مبهم‌نگاری شده‌است و ابهام در کد‌های کتابخانه‌ای را نادیده گرفته‌اند.

\فقره \مهم{مبتنی بر شباهت‌سنجی و کد‌های تکراری:} در این روش، ابتدا مخزن بزرگی از کتابخانه‌های اندرویدی تهیه می‌شود و به روش‌های گوناگون کد‌های کلاسی برنامک و کد‌های کتابخانه‌ای موجود در مخزن، با یکدیگر مقایسه می‌شوند و بدین طریق کتابخانه‌های اندرویدی از کد‌های مورد توسعه در برنامک، جدا می‌شود. روش‌های مبتنی بر شباهت‌سنجی، بسته به این‌که از چه روشی برای یافتن کد‌های تکراری استفاده می‌کنند، دقت‌های متفاوتی دارند اما به صورت کلی می‌توان گفت که مقاومت آن‌ها در مقابل مبهم‌نگاری بسیار بیشتر از روش‌های مبتنی بر لیست سفید است چرا که در صورتی که ویژگی‌های منتخب مقابل مبهم‌نگاری مقاوم باشند، آن‌گاه می‌توان گفت که درصد بالایی از کتابخانه‌های اندرویدی را می‌توان از کد اصلی برنامک جدا کرد.

\پایان{فقرات}

\زیرقسمت{استخراج ویژگی}
پس از حذف کد‌های کتاب‌خانه‌ای در قسمت قبلی و انجام پیش‌پردازش‌های مورد نیاز، کد‌های منبع برنامک هدف، به یک طرح کلی مدل می‌شود. به صورت کلی می‌توان روش‌های تشخیص برنامک‌های بازبسته‌بندی شده را در پژوهش‌های سالیان اخیر، ناشی از تفاوت در دیدگاه در مرحله‌ی استخراج ویژگی\پاورقی{Feature Extracting} دانست. همانطور که در شکل ~\رجوع{شکل:دسته‌بندی} مشاهده می‌شود، روش‌های تشخیص برنامک‌های بازبسته‌بندی به صورت کلی به دو بخش تحلیل ایستا و تحلیل پویا تقسیم می‌شود. از آن‌جایی که هدف ما در این پژوهش، تنها بررسی پژوهش‌هایی است که روش‌های تشخیص بازبسته‌بندی ارائه داده‌اند بنابراین روش‌هایی که توسعه‌دهندگان و شرکت‌های توسعه‌دهنده جهت جلوگیری از انجام بازبسته‌بندی پیاده‌سازی می‌کنند را به صورت خلاصه‌تر شرح خواهیم‌داد. به صورت کلی، می‌توان روش‌های تشخیص برنامک‌های بازبسته‌بندی شده را به دو بخش روش‌های تحلیل پویا و یا روش‌های تحلیل ایستا تقسیم کرد که در ادامه به بررسی هر کدام از این روش‌های می‌پردازیم. 
\شروع{فقرات}
\فقره\مهم{روش‌های مبتنی بر تحلیل ایستا:} روش‌های مبتنی بر تحلیل ایستا، در مقابل مبهم‌نگاری‌‌های ایستا که در هنگام بازبسته‌بندی و انجام دی‌کامپایل انجام می‌شود مقاوم هستند. اما همانطور که می‌توان حدس زد، این دسته از روش‌ها مقابل روش‌های مبهم‌نگاری همانند بازتاب مقاومتی ندارند و ممکن است دچار خطا شوند. همچنین روش‌های مبهم‌نگاری مبتنی بر رمز‌نگاری پویا نیز این روش‌‌ها را دچار خطا می‌کند. یکی از مزایای مهم روش‌های مبتنی بر تحلیل ایستا آن است که در صورت پیاده‌سازی درست و استفاده از ویژگی‌های مقاوم، می‌توانند طیف وسیعی از برنامک‌های بازبسته‌بندی شده را تشخیص دهند.

\فقره\مهم{روش‌های مبتنی بر تحلیل پویا:} ارائه‌ی روش‌های مبتنی بر تحلیل پویا، به هدف جلوگیری از مبهم‌نگاری‌های در لحظه‌ی اجرا\پاورقی{Execution Time} که در برنامک‌های اندرویدی صورت می‌گیرد، می‌باشد. به همین علت روش‌های موجود در این حوزه، عمدتا برنامک‌ها را در هنگام اجرا بررسی و  استخراج ویژگی عمدتا در هنگام اجرا انجام می‌گیرد. به طول کلی، روش‌های مبتنی بر تحلیل پویا از مقاومت بیشتر در مقابل استفاده از راهکار‌های مبهم‌نگاری برخوردار هستند. استفاده از شبیه‌ساز‌های جعبه‌شن\پاورقی{Sand Box} به وفور در پژوهش‌های این حوزه، یافت می‌شود. یکی از چالش‌های اصلی در تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده، چگونگی پیاده‌سازی شبیه‌ساز‌ ها\پاورقی{Simulator}ست. بسیار از شبیه‌سازها توانایی شبیه‌سازی تمامی خدمات موجود در برنامک‌ را ندارند و برای تحلیل دقیق‌تر نیازمند استفاده از کاربران واقعی در شبیه‌سازی و استفاده از خدمات برنامک هستند. عامل دیگری که تشخیص با استفاده از تحلیل پویا را مشکل می‌کند، این است که بسیاری از بدافزار‌های توسعه‌یافته، توانایی تشخیص محیط اجرای شبیه‌سازی‌شده را دارند و ممکن است تمامی قابلیت‌های خود و یا بخشی از آن‌ را به جهت دور زدن سیستم‌های تشخیص پویا، پنهان کنند.
\پایان{فقرات}

\زیرقسمت{تشخیص باز‌بسته‌بندی}
در این مرحله با توجه به معیار‌ها و ویژگی‌هایی که از قسمت قبل به دست آمده است و با استفاده از روش‌های گوناگون برنامک بازبسته‌بندی شده مشخص می‌شود. به صورت کلی، روش‌های پیاده‌سازی شده در این قسمت، مبتنی بر مقایسه‌ی دودویی و یا طبقه‌بندی و یادگیری ماشین هستند.

\شروع{فقرات}
\فقره\مهم{مقایسه‌ی دودویی:} روش‌های مبتنی بر مقایسه‌ی دودویی، مدل استخراج شده در قسمت قبلی را با استفاده از شباهت‌سنجی با برنامک‌های موجود در مخزن مقایسه می‌کند و در نهایت برنامک بازبسته‌بندی شده را مشخص می‌کند. اکثر روش‌های مبتنی بر مقایسه‌ی دودویی، جفت برنامک اصلی را نیز مشخص می‌کنند و از تعریف
\ref{tarif1}
استفاده می‌کنند بنابراین یکی از مزیت‌های این روش‌ها پوشش گسترده‌تر از تعریف تشخیص بازبسته‌بندی است ولی در کنار آن اکثر روش‌های موجود در این زمینه، محاسبات بالایی دارند که باعث می‌شود سرعت آن‌ها کاهش یابد.
\فقره {\مهم{مبتنی بر طبقه‌بندی و یاد‌گیری ماشین:}} یکی دیگر از روش‌های تشخیص بازبسته‌بندی با استفاده از ویژگی‌های مستخرج از مرحله‌ی قبل، استفاده از طبقه‌بند ها و مدل‌های یادگیری ماشین است. اکثر پژوهش‌های موجود در این زمینه از تعریف
\ref{tarif2}
برای تشخیص برنامک بازبسته‌بندی شده استفاده می‌کنند. بنابراین، تنها تصمیم‌گیری در مورد بازبسته‌بندی بودن یا نبودن برنامک ورودی را انجام می‌دهند. یکی از مزایای مهم این رو‌ش‌ها، سرعت بالای آن است چرا که تنها در زمان مرحله‌ی یادگیری، نیازمند محاسبات بالایی هستند و در صورتی که مدل این روش‌ها به درستی عمل کند، سرعت تشخیص به صورت قابل توجهی بالاتر از روش‌های مبتنی بر مقایسه‌ی دودویی است.
\پایان{فقرات}

\قسمت{روش‌های تشخیص بازبسته‌بندی}
همانطور که در شکل ~\رجوع{شکل:دسته‌بندی} مشاهده می‌شود، اکثر پژوهش‌های تشخیص بازبسته‌بندی از روش‌های مقایسه‌ای مبتنی بر تحلیل ایستا و پویا استفاده می‌کنند. در ادامه‌ی این قسمت ابتدا روش‌های ایستا و همچنین پژوهش‌های اخیر مرتبط با این حوزه را بررسی خواهیم کرد و در ادامه روش‌های مبتنی بر تحلیل پویا شرح داده می‌شود.
\شروع{شکل}[H]
\centerimg{mindmap}{16cm}
\vspace{1em}
\شرح{شمای کلی امضای متد در پژوهش}
\برچسب{شکل:دسته‌بندی}
\پایان{شکل}
\زیرقسمت{مبتنی بر تحلیل ایستا}
همانطور که گفتیم تحلیل ایستا، روشی محبوب در میان پژوهش‌های اخیر موجود در این حوزه است چرا که پیچیدگی‌های روش‌های پویا را ندارد و می‌توان به کمک آن‌ها طیف وسیعی از تشخیص مبهم‌نگاری‌ها را در برنامک‌های اندرویدی بازبسته‌بندی شده پشتیبانی کرد.

\زیرزیرقسمت{روش‌های مبتنی بر آپکد و دستورات}
استفاده از آپکد\پاورقی{Opcode}‌های موجود در فایل‌های دالویک، یکی از روش‌های تشخیص برنامک‌های بازبسته‌بندی شده است. هدف از پژوهش آقای ژو و همکاران \مرجع{opcode1}، توسعه‌ی ابزاری به نام درویدمس\پاورقی{DroidMoss} بوده است که توسط آن مشخص شود چه تعدادی از برنامک‌های موجود در فروشگاه‌های اندرویدی غیررسمی، بازبسته‌بندی شده‌ی برنامک‌های موجود در فروشگاه‌های رسمی هستند. همانطور که گفته شد نظارت کافی‌ای بر روی فروشگاه‌های غیر رسمی وجود ندارد، بنابراین متقلبین از این فروشگاه‌ها به عنوان یک راه امن و دردسترس برای پخش‌کردن برنامک‌های بازبسته‌بندی شده استفاده می‌کنند. برای استخراج امضا‌ی برنامک در این پژوهش از کد‌های دالویک موجود در \کد{Classes.dex} و امضای دیجیتال برنامه‌نویس در فراداده‌\پاورقی{MetaData} استفاده‌شده است. پس از جداسازی کد‌های کتابخانه‌ای به وسیله‌ی لیست سفید و استخراج آپکد‌ها از فایل‌های دالویک، از یک پنجره‌ی لغزان\پاورقی{Sliding Window} روی آپکد‌ها استفاده شده و در نهایت چکیده‌\پاورقی{Hash}ی آپکد‌ها به همراه امضای دیجیتال برنامه‌نویس، موجود در پوشه‌ی META-INF تشکیل امضا‌ی برنامک را می‌دهند. همانطور که می‌توان فهمید، فرض پژوهش این بوده است که کلید خصوصی توسعه‌دهنده لو نرفته‌است. در نهایت برای قسمت‌ شباهت‌سنجی، از الگوریتم فاصله ویرایشی\پاورقی{Edit Distance} استفاده‌شده است. در قسمت شباهت‌سنجی از ۲۲۹۰۶ برنامک موجود در فروشگاه‌های رسمی استفاده شده‌ و نتایج پژوهش نشان می‌دهد که ۵ تا ۱۳ درصد از برنامک‌های موجود در فروشگاه‌های غیر رسمی، بازبسته‌بندی شده‌ی برنامک‌های فروشگاه‌های رسمی است. در پژوهش دیگری که توسط آقای ژو\مرجع{Gonzalez2015} ارائه شده‌است، هدف پژوهش، افزایش سرعت پژوهش‌ قبلی با استفاده از نمونه‌های n تایی از آپکد‌ها بوده است. در این پژوهش امضای هر برنامک متشکل از قسمتی از فراداده‌ی آن شامل فایل‌های منیفست\پاورقی{Manifest} و اطلاعاتی در مورد تعداد فایل‌های برنامک، توصیفات آن و چکیده‌ی آپکد‌های دستورات برنامه‌ است. این پژوهش با استفاده از یک مرحله پیش‌پردازش شامل بررسی فایل فراداده‌ی برنامک‌های موجود،‌فضای جست‌و‌جوی دودویی برنامک‌های مورد مقایسه را کاهش می‌دهد.دزنوز و همکاران\مرجع{6149548} روش‌دیگری را مبتنی بر شباهت‌سنجی روی آپکد‌ها با استفاده از فاصله‌ی فشرده‌سازی نرما‌ل‌شده ارائه کرده‌اند. در این پژوهش ابتدا برای هر متد با توجه به دنباله‌ی دستورات موجود امضای مشخصی تولید می‌شود و در مرحله‌ی بعد متد‌هایی که بکتا هستند از هر دو برنامک، بر اساس معیار فاصله‌ی فشرده‌سازی نرمال‌شده با یکدیگر مقایسه و بدین ترتیب متد‌های مشابه‌ استخراج می‌شود. در پژوهش \مرجع{Rad2011,6333411} پس از استخراج هیستوگرام‌های مربوط به تکرار آپکد‌ها در قسمت‌های مختلف برنامک، هیستوگرام‌ها با استفاده از معیار فاصله‌ی  مینی‌کاوسکی که یک معیارفاصله‌ی مبتنی بر هیستوگرام‌ها است مقایسه‌ می‌شوند و در نهایت برنامک‌های بازبسته‌بندی شده مشخص می‌شوند. جرومه و همکاران\مرجع{6883436} در پژوهش خود با استفاده از آپکد‌ها و تکرار آن‌ها و روش‌های مبتنی بر یادگیری ماشین برنامک‌های بازبسته‌بندی شده را تشخیص می‌دهند.در پژوهشی که توسط سرنیل و همکاران \مرجع{6566472}، ارائه‌شده است، از نمونه‌برداری مبتنی بر $-n$ گرام در ۴ اندازه‌ی متفاوت ۱ تا ۴ استفاده شده‌است. برای شباهت‌سنحی از روش‌های طبقه‌بندی مبتنی بر درخت‌تصمیم، شبکه‌های عصبی و بردار ماشین استفاده شده‌است.

آقای لین و همکاران\مرجع{Lin2013} در پژوهش خود، با استفاده از فراخوانی‌های سیستمی\پاورقی{System calls}‌ صدا زده‌شده توسط برنامک، رفتار آن را طبقه‌بندی می‌کنند. به عقیده‌ی این پژوهش، از آن‌جایی که اکثر بدافزار‌های هم‌خانواده، در بازبسته‌بندی برنامک‌های اندرویدی، رفتار مشابه یکدیگر دارند، بنابراین استفاده از فراخوانی‌های سیستم و استخراج آن‌ها از سطح بایت‌کد‌های دالویک و سطح نخ\پاورقی{Thread}‌، می‌تواند امضاء یکتایی از هر برنامک تولید کند. پس از استخراج بردار ویژگی\پاورقی{Feature Vector}‌ از فراخوانی‌های موجود با استفاده از آپکد‌های برنامک، از یک طبقه‌بند بیز برای شباهت‌سنجی استفاده شده‌است. با توجه به روش پژوهش، شناسایی و طبقه‌بندی بدافزار‌های بازبسته‌بندی شده‌ای که رفتار مشخصی ندارند و در مخزن بدافزار‌ها موجود نیستند، یکی از ویژگی‌های مفید پژوهش ارائه‌شده است. فروکی و همکاران  \مرجع{6714172} در پژوهش خود یک راه حل مبتنی بر استفاده از بلاک‌های ۶۴ بایتی بر روی فایل‌های دودویی برنامک‌های اندرویدی ارائه‌کرده ‌اند. در روش ارائه‌شده پس از استخراج بلاک‌های ۶۴ بایتی از فایل‌ها و با استفاده از چکیده‌ خلاصه تشابه و استخراج آنتروپی\پاورقی{Entropy}‌ برای هر بلاک، بلاک‌هایی که کوچکتر و بزرگتر از یک حد کمینه و آستانه باشند حذف می‌شوند. سپس به هر بلاک با توجه آنتروپی آن، یک اولویت\پاورقی{Priority} اختصاص پیدا کرده که نشان می‌دهد بلوک مورد نظر دارای آنتروپی با احتمال بیشتر است. در نهایت پس از حذف بلوک‌هایی که احتمال رخداد پایین‌تری دارند نرخ مثبت غلط پژوهش کاهش یافته و از یک روش مبتنی بر بلوم‌فیلتر\پاورقی{Bloom filter}‌ برای مقایسه‌ و شباهت‌سنجی استفاده می‌شود.

آقای کو و همکاران\مرجع{2513308} از یک راه‌حل مبتنی بر استفاده از $-k$گرام برای تشخیص بسته‌های بازبسته‌بندی شده استفاده کرده‌اند. نویسندگان، از  حذف عملوند‌های\پاورقی{Operand}‌ موجود در کد‌های دودویی، به‌ جهت کاهش مثبت‌های غلط در تشخیص بسته‌های بازبسته‌بندی شده استفاده کرده‌اند.
در پژوهش کیشو و همکاران \مرجع{Kishore2018} از یک راه‌حل مبتنی بر ترکیبی از دستورات کلاسی و متد‌های برنامک استفاده ‌کرده‌اند‌. در این پژوهش، در دو مرحله، ابتدا کلاس‌های مشابه‌ با یکدیگر مشخص می‌شود و سپس در داخل کلاس‌های مشابه، متد‌هایی که یکسان هستند یافت می‌شود. شباهت‌سنجی میان کلاس‌ها، با استفاده از سه ویژگی، شامل لیست تمامی‌ متد‌های کلاس شامل ورودی و خروجی، لیست متغیر‌های کلاسی و لیست کلاس‌هایی که داخل این کلاس فراخوانی ‌شده‌اند، انجام می‌شود. پس از استخراج کلاس‌های مشابه، برای یافتن متد‌های مشابه میان دو کلاس، از یک امضای مشترک شامل توصیف متد‌ها به همراه نوع ورودی و خروجی آن‌ها و همچنین نام آن‌ها استفاده می‌شود. شباهت‌سنجی با استفاده از فاصله‌ی فشرده‌سازی\پاورقی{Compression Distance} انجام شده‌است.

راهول و همکاران\مرجع{Potharaju2012}، روشی را پیشنهاد کرده‌اند که در آن استخراج ویژگی مبتنی بر درخت نحو انتزاع\پاورقی{Abstract Syntax Tree} انجام می‌شود. ابزار پیشنهادی در این پژوهش پس از دستیابی به کد میانی برنامک‌های اندرویدی و تبدیل آن به مجموعه‌ای از قوانین نحوی، که به صورت مجموعه‌ای از عبارات منظم\پاورقی{Regular Expressions}‌ هستند، درخت نحو انتزاع را در سطح تابع تشکیل می‌دهد و سه ویژگی تعداد ورودی هر تابع، نام توابع صدازده‌شده به صورت مستقیم و مجازی\پاورقی{Virtual}‌ و متغیر‌های شرطی را استخراج می‌کند. سپس برای طبقه‌بندی از الگوریتم نزدیک‌ترین همسایه‌ به جهت تشخیص بازبسته‌بندی استفاده شده‌است. نرخ منفی غلط بسیار پایین از ویژگی‌های مورد توجه این پژوهش است. همچنین برای ذخیره‌سازی درخت نحو انتزاع، از یک ساختار مبتنی بر درخت \کد{$B+$} و پایگاه‌داده‌ی \کد{$MySql$} استفاده شده‌است.

به صورت کلی می‌توان گفت که روش‌های مبتنی بر دستورات، خصوصا روش‌هایی که به صورت مستقیم از آپکد برای تشخیص برنامک‌های بازبسته‌بنده شده استفاده می‌کنند، توانایی بالایی را در تشخیص برنامک‌های بازبسته‌بندی شده ارائه‌ نمی‌دهند. این روش‌ها هم‌اکنون مقابل ساده‌ترین مبهم‌نگاری‌ها نظیر تغییر نام بسته‌ها و کلاس‌ها مقاوم نیستند و بخش زیادی از پژوهش‌های این حوزه، بازبسته‌بندی را بدون تغییر در کد‌های برنامک اصلی تعریف کرده‌اند که به نظر با توجه به وجود مبهم‌نگارهای امروزی، این فرضی غلط و غیر قابل اتکا است.

\زیرزیرقسمت{روش‌های مبتنی بر گراف }
به صورت کلی می‌توان پژوهش‌های صورت‌گرفته در دسته‌ روش‌های مبتنی بر گراف، را از دو جنبه بررسی کرد. دیدگاه اول پژوهش‌هایی هستند که در نهایت امضاء هر برنامک را با استفاده از یک مدل گرافی نشان می‌دهند. در این دسته از پژوهش‌ها، برای مقایسه‌ی امضا، ناچاراً از الگوریتم‌های تشابه گراف نظیر الگوریتم‌های تشخیص گراف‌های هم‌ریخت استفاده می‌شود و به علت سربار محاسباتی بسیار بالای این پژوهش‌ها، روش‌های این دسته بسیار کند هستند. دیدگاه دوم پژوهش‌هایی هستند که صرفاً با بررسی ویژگی‌های مبتنی بر گراف‌های جریان و داده‌ای میان قسمت‌‌های مختلف، ویژگی‌های هر برنامک را استخراج کرده و در نهایت امضاء هر برنامک را تشکیل می‌دهند. همانطور که می‌توان حدس زد، دسته‌ی دوم از سرعت بالاتری در تشخیص برخوردار است اما چگونگی مدل‌سازی با استفاده از ویژگی‌های گرافی، بخش مهمی در پژوهش‌های این دسته است که باید به دقت پیاده‌سازی شود.

در پژوهشی که توسط آقای کروسل و همکاران \مرجع{Crussell2013}، ابزاری مبتنی بر گراف وابستگی توسعه‌داده‌ شده‌است. در این ابزار ابتدا، برنامک‌های موجود در مخزن با استفاده از یک ابزار شباهت‌سنجی در سطح فراداده‌\پاورقی{Meta Data}‌ی برنامک، به جهت افزایش سرعت، کاهش‌می‌یابد. پس از حذف کد‌های کتابخانه‌ای به روش لیست سفید، امضاء هر برنامک با استفاده از گراف وابستگی استخراج‌شده تشکیل می‌گردد. گراف وابستگی توابع، وابستگی اجزای یک تابع از دو منظر کنترلی و داده‌ای را معرفی می‌کند. وابستگی کنترلی\پاورقی{Control Dependency}‌ در این پژوهش، الزام اجرای یک دستور خاص پیش از دستور دیگری است و وابستگی داده‌ای\پاورقی{Data Dependency}‌، الزام مقداردهی متغیر پیش از اجرای دستور مرتبط با آن است. در قسمت شباهت‌سنجی پس از ساخت گراف وابستگی داده‌ای، با استفاده از الگوریتم تشخیص گراف‌های هم‌ریخت \پاورقی{Graph Isomorphism }‌\کد{VF2} شباهت‌سنجی انجام شده و بسته‌های بازبسته‌بندی شده مشخص می‌شوند. در پژوهش دیگری که توسط آقای سان\مرجع{wu2012} انجام‌ شده‌است، هدف پژوهش افزایش دقت تشخیص برنامک‌های بازبسته‌بندی شده با تاکید بر شبیه‌سازی رفتار برنامک بوده‌است. در این پژوهش، واسط‌های برنامه‌نویسی برنامک‌های اندرویدی مشخص کننده‌ی رفتار اصلی برنامک در نظر گرفته‌شده است. برای ساخت گراف هر برنامک، از گراف جریان مبتنی بر فراخوانی واسط‌های اندرویدی استفاده شده و در نهایت پس از استخراج گراف، هر گراف نمایانگر امضاء یک برنامک می‌باشد. در گراف حاصل هر گره گراف حاوی اطلاعات یک واسط و یال‌های گراف شامل جریان کنترلی بین واسط‌های اندرویدی است. برای شباهت‌سنجی، از الگوریتم \کد{$VF2$} جهت تشخیص گراف‌های هم‌ریخت استفاده شده‌است. در مرحله‌ی آخر برنامک‌هایی که امضا‌ء مشابه و یکسانی در تشخیص هم‌ریختی دریافت کرده‌اند به عنوان برنامک‌های بازبسته‌بنده شده در نظر گرفته می‌شوند.

پژوهش آقای هو و همکاران\مرجع{6911805} شامل دو مرحله‌ی ساخت گراف فراخوانی متد‌های\پاورقی{Method Invocation Graph}‌ برنامک و ماژول تشخیص بازبسته‌بندی است. پس از دیس‌اسمیل کردن فایل‌های برنامک، گراف فراخوانی متد‌های برنامک تشکیل شده و تشکیل جنگلی از گراف‌های متصل و جدا از هم می‌دهند.سپس با استفاده از فراخوانی‌ واسط‌های اندرویدی موجود در هر متد، گراف به دو بخش فراخوانی‌های حساس\پاورقی{Sensitive}‌ و غیرحساس\پاورقی{Non-Sensitive}‌ تقسیم می‌شود و با توجه به میزان حساسیت واسط‌های فراخوانی‌شده، امتیاز اولویت\پاورقی{Priority Score}‌ به هر گراف نگاشت می‌شود و در نهایت با استفاده از مقایسه‌ی گرافی مبتنی بر امتیاز اولویت، شباهت‌سنجی انجام می‌شود.

از آن‌جایی که پژوهش‌های مبتنی بر گراف در تشخیص برنامک‌های بازبسته‌بندی، عمدتا به دلیل استفاده از روش‌های تشخیص گراف‌های همریخت کند هستند، ژو و همکاران \مرجع{Zhou2013} روشی برای افزایش سرعت در تشخیص ارائه کرده‌اند. در این پژوهش در ابتدا ماژول‌های اصلی برنامک که رفتار اصلی آن را شکل می‌دهند شناسایی می‌شود. برای شناسایی ماژول‌های اصلی برنامک، از یک گراف جهت‌دار مبتنی بر ارتباط بسته\پاورقی{Package}‌‌های برنامک با یکدیگر استفاده شده و در نهایت یال‌های گراف بر اساس میزان ارتباطات بین بسته‌ها، مقدار‌دهی می‌شود. با تشکیل گراف وزن‌دار ابتدایی، بسته‌هایی که ارتباط آن‌ها بر اساس وزن یال بین دو‌بسته از یک مقدار آستانه بیشتر باشد، با یکدیگر ادغام می‌شوند و رویه‌ی ادغام بسته‌ها در یک روند بازگشتی تا زمانی که هیچ بسته‌ای را نتوان با یکدیگر ادغام کرد تکرار می‌شود. در این حالت بسته‌ی نهایی شامل بسته‌ی اصلی برنامک است که منطق برنامک در این قسمت پیاده‌سازی شده‌است. رویه‌ی ساخت گراف ارتباطی بین بسته‌‌ها و ایده‌ی استفاده شده در قسمت ادغام بسته‌های اصلی با یکدیگر، ایده‌ای نو در این حوزه‌ است که منجر به افزایش سرعت تشخیص نسبت به تمامی روش‌های گرافی شده‌است. برای مقایسه‌ی میان ماژول‌های اصلی برنامک، ابتدا اصلی‌ترین ماژول شامل بیشترین تعداد فعالیت، مشخص می‌شود و مقایسه میان ماژول‌های اصلی برنامک‌های اندرویدی،‌ با استفاده از یک بردار ویژگی متشکل از فراخوانی‌ واسط‌ها و مجوز‌های\پاورقی{Premessions}‌ درخواستی انجام می‌شود. برای مقایسه از درخت $VP$\پاورقی{Vantage-Point Tree}‌ استفاده شده‌است که منجر به افزایش سرعت در کنار دقت مناسب شده‌است. برخلاف روش‌های معمول گرافی و در نهایت مقایسه‌ی دو‌دویی، روش پیاده‌سازی شده در پژوهش ژو، با مرتبه‌ی زمانی \کد{$n.logn$} یکی از پر سرعت‌ترین روش‌های مبتنی بر تشکیل گراف می‌باشد.

در پژوهش دیگری که به جهت افزایش سرعت در دسته‌ پژوهش‌های مبتنی بر گراف ارائه شده‌است، چن و همکاران\مرجع{Chen2014} با استفاده از مدل کردن گراف به یک فضای سه‌بعدی، سرعت تشخیص و مقایسه‌ی گراف‌های هم‌ریخت را به مراتب افزایش داده‌اند. ایجاد کد‌های مرده\پاورقی{Dead Code}‌ در کد‌های برنامک، منجر به تغییر گراف‌ جریان برنامک‌های اندرویدی می‌شود به همین جهت در این پژوهش تمامی گره‌های گرافی که نشان‌دهنده‌ی متد‌های برنامک هستند به یک فضای سه‌بعدی نگاشت شده و مرکز جرم هر گراف با توجه به مختصات گره‌های گرافی تعیین می‌شود. در قسمت مقایسه‌ی گرافی، مرکز جرم گراف‌‌های متناظر با یکدیگر مقایسه شده و کاندید‌های بازبسته‌بندی مشخص می‌شود. در مرحله‌ی بعد برای مقایسه‌ی گره‌های هر گراف و تطبیق گراف‌های کاملا متناظر، از مقایسه‌ی فاصله‌ی ویرایشی گره‌های متناظر استفاده می‌شود. روش ارائه‌شده علاوه بر مقاومت بالا مقابل مبهم‌نگاری، ناشی از مدل‌کردن برنامک در یک فضای گرافی، به دلیل استفاده از روشی نو در مقایسه‌ی گراف‌های مخزن برنامک‌ها، سرعت بسیار بالاتری از روش‌های پیشین دارد. برای حذف کتاب‌خانه‌های اندرویدی از روش لیست سفید مبتنی بر اندازه‌ی بسته‌های مورد مقایسه استفاده شده‌است.

بر خلاف پژوهش‌های رایج در حوزه‌ی تشخیص بازبسته‌بندی برنامک‌های اندرویدی، در پژوهش آقای آلدینی و همکاران\مرجع{Adhianto2010}، از یک معماری کارخواه-کارگزار\پاورقی{Client-Server}‌ مطابق با شکل ~\رجوع{شکل:آلدینی}، برای تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده استفاده شده‌است. در این معماری یک برنامک بر روی دستگاه اندرویدی کاربران نصب می‌شود و شروع به ثبت و ارسال فراخوانی‌های سیستمی به کارگزار می‌کند.
\شروع{شکل}[H]
\centerimg{4}{12cm}
\vspace{1em}
\شرح{مراحل تشخیص برنامک‌های بازبسته‌بندی شده در پژوهش آقای آلدینی\مرجع{Adhianto2010}}
\برچسب{شکل:آلدینی}
\پایان{شکل}
ایده‌ی پژوهش، استفاده از فراخوانی‌های سیستمی برای شبیه‌سازی ایستا‌ی رفتار برنامک‌های اندرویدی بوده است. اثرانگشت برنامک توسط گراف فراخوانی‌های سیستمی ارسالی از سمت کاربران در سمت کارگزار، تشکیل می‌شود سپس با استفاده از اثرانگشت موجود، یک مدل برنامک تحت عنوان قرارداد ساخته شده و این مدل به برنامه‌ی کارخواه فرستاده می‌شود. در سمت کارخواه، برنامک نصب‌شده در مرحله‌ی اول، فراخوانی‌های سیستمی برنامک موجود را با قرارداد فرستاده‌شده مطابقت می‌دهد و در صورتی که فاکتور‌هایی نظیر نوع و تعداد فراخوانی‌های اندرویدی برنامک، با مدل پیش‌بینی شده یکسان نباشد، هشدار لازم از طریق برنامک نصب‌شده روی کارخواه به کاربر داده می‌شود. در کنار استفاده از گراف فراخوانی‌‌های سیستمی، پیاده‌سازی یک معماری کارخواه و کارگزار یکی از ایده‌های نو در این پژوهش بوده‌است. همچنین به دلیل استفاده از این معماری، پردازش سمت کارخواه به حداقل خود رسیده است و تحلیل برنامک نیازمند هیچ دانش اولیه‌ای از سمت کارخواه نمی‌باشد. علاوه بر این، تعداد برنامک‌های موجود در مخزن کارگزار، به صورت مرتب افزایش پیدا کرده و این موجب پویایی مخزن برنامک‌های اندرویدی پژوهش می‌شود. 

پژوهش دیگری در زمینه‌ی روش‌های تشخیص بازبسته‌بندی مبتنی بر گراف توسط جنگ و همکاران\مرجع{7752544} ارائه شده‌است. در این پژوهش، پس از استخراج گراف ارتباط بین کلاس‌ها از داخل بایت‌کد‌های دالویک برنامک اندرویدی، امضای هر برنامک شامل یک بردار ویژگی، متشکل از فراخوانی‌‌های کلاسی برنامک می‌باشد. مقایسه‌ی بردار‌های برنامک‌های موجود به وسیله‌ی الگوریتم یافتن بزر‌گ‌ترین زیر‌دنباله‌ی مشترک\پاورقی{Longest common Subsequence}‌ انجام شده و تعیین یک حد آستانه در زیر‌دنباله‌های مشترک، برنامک‌ بازبسته‌بندی شده شناسایی می‌شود. روش مورد نظر را می‌توان به نوعی یک روش مبتنی بر گراف و دنباله‌ی آپکد‌های برنامک توصیف کرد چرا که از هر دو ایده‌ی مدنظر استفاده نموده‌است. یکی دیگر از آخرین پژوهش‌های موجود در این دسته،‌در سال ۲۰۲۱ توسط نگویان\مرجع{9701544} مطرح شده‌است. پژوهش مورد نظر مبتنی بر استخراج گراف فعالیت‌\پاورقی{Activity Graph}‌ در برنامک‌های اندرویدی است. همانطور که در شکل ~\رجوع{شکل:نگویان} مشاهده می‌شود، گره‌های گراف مورد نظر شامل لیستی از واسط‌های فراخوانی‌شده در آن فعالیت و یال‌های گراف، نشان‌دهنده‌ی یک انتقال از یک فعالیت به فعالیتی دیگر‌ است. یکی از معایب این پژوهش استفاده از الگوریتم \کد{VF2} به عنوان الگوریتم اصلی برای مقایسه‌ و یافتن گراف‌های هم‌ریخت است که باعث کاهش سرعت پژوهش شده‌است.
\شروع{شکل}[H]
\centerimg{5}{8cm}
\vspace{1em}
\شرح{گراف فعالیت و محتوای گره‌های آن در پژوهش نگویان\مرجع{9701544}}
\برچسب{شکل:نگویان}
\پایان{شکل}

به عنوان آخرین پژوهش صورت گرفته در این قسمت، پژوهش\مرجع{msctorki,phdwang} را بررسی خواهیم کرد. پژوهش \مرجع{phdwang} که الهام‌دهنده‌ی پژوهش \مرجع{msctorki} می‌باشد با استفاده از پیمایش گرافی برروی گراف‌ جریان برنامک‌های اندرویدی و استخراج ویژگی‌های متعدد نظیر واسط‌های اندرویدی، فراخوانی توابع و استفاده از فیلتر‌های ساختاری نظیر اندازه‌ی طول امضا، امضا‌ی هر کلاس را تشکیل می‌دهد و در نهایت با استفاده از الحاق تمامی کلاس‌های برنامک (مرتب شده به صورت الفبایی) امضا‌‌ء مخصوص هر برنامک ساخته می‌شود. تفاوت این دوپژوهش بیشتر در ساختار امضاء هر برنامک می‌باشد که در فصل
\ref{ourwork}
به توصیف بیشتر این دو پژوهش و شرح تفاوت‌های آن خواهیم پرداخت.

به طور کلی می‌توان گفت که روش‌های گرافی تشخیص برنامک‌های بازبسته‌بندی شده از دقت بالایی در تشخیص برخوردار هستند. از طرفی اکثر روش‌های ارائه‌شده در این دسته، خصوصاً آن‌هایی که در نهایت هر برنامک را به یک طرح گرافی مدل می‌کنند، روش‌های تشخیص گراف‌های هم‌ریخت را در قسمت مقایسه به کار گرفته‌اند که این موضوع باعث می‌شود تا سربار محاسباتی سنگینی به پژوهش‌های مطرح وارد و سرعت تشخیص را کند سازد. علاوه بر این همانطور که بررسی شد روش‌های ارائه‌شده، در صورتی که مدل‌های گرافی را در فضای دیگری بررسی کنند، سرعت تشخیص روش بالاتر رفته و می‌توان از دقت در تشخیص مسائل گرافی نیز استفاده نمود.


\زیرزیرقسمت{روش‌های مبتنی بر تحلیل ترافیک شبکه}
از آن‌جایی که ترافیک شبکه‌ی\پاورقی{Network Traffic} عبوری از برنامک‌هایی که مبتنی بر فضای مجازی عمل می‌کنند، می‌تواند رفتار خوبی از برنامک را مدل کند بنابراین استفاده از ویژگی‌های مبتنی بر این ترافیک شبکه، از محبوبیت بالایی میان توسعه‌دهندگان، برخوردار است. به عنوان اولین پژوهش مورد بررسی، پژوهش ارائه‌شده توسط وو و همکاران \مرجع{1170} را بررسی خواهیم کرد. در این پژوهش امضا‌ی هر برنامک مبتنی بر ترافیک \کد{http} تولیدشده توسط آن درست می‌شود. در مرحله‌ی اول این پژوهش، تمامی ترافیک‌ تولید‌شده توسط برنامک جمع‌آوری شده و در مرحله‌ی بعدی ترافیک \کد{http} جداسازی و تحلیل روی این دسته ادامه پیدا می‌کند. ترافیک حاصل از برنامک‌های اندرویدی در این پژوهش به دو دسته‌ی کلی تقسیم می‌شود:
\شروع{فقرات}
\فقره ترافیک مرجع\پاورقی{Source}‌: ترافیک تولید‌شده توسط برنامک توسعه‌یافته
\فقره ترافیک کتابخانه‌ای: ترافیک تولید‌شده توسط کد‌های کتابخانه‌ای
\پایان{فقرات}

جهت جداسازی ترافیک مرجع و ترافیک کد‌های کتاب‌خانه‌ای از الگوریتم‌های تطبیق جریان ترافیک\پاورقی{Traffic Stream Matching}‌ \کد{http} و الگوریتم تطبیق هانگرین\پاورقی{Hungarian Matching}‌ استفاده شده‌است. در قسمت شباهت‌سنجی از درخت جست‌وجوی \کد{VPT} به جهت افزایش سرعت به دلیل متوازن بودن درخت، استفاده شده ‌است. پژوهش مورد نظر ایده‌ای نو در زمینه‌ی تشخیص برنامک‌های بازبسته‌بندی شده است اما مشکل اصلی این پژوهش آن است که در مقابل ترافیک رمز‌نشده مقاوم نیست و عملا در برنامک‌هایی که تمامی ترافیک تولیدی توسط آن‌ها رمزگذاری شده‌است ناکارامد می‌شود.

در پژوهشی که توسط الشهری\مرجع{Alshehri2022} ارائه‌شده است تفکیک ترافیک به وسیله‌ی یک طبقه‌بند انجام می‌‌شود. پس از تفکیک ترافیک متغیر‌های هر بسته شامل \کد{Request,Value,Get,Host} مشخص‌ می‌شود. ترافیک‌های از نوع \کد{Request} در این قسمت به دو نوع اجباری و یا غیراجباری تقسیم می‌شود.ترافیک غیر اجباری شامل ترافیک مصرفی برنامک برای ارتباط با واسط‌های دسترسی عنوان شده‌است. جداسازی ترافیک‌های شبکه از آن‌ جهت اهمیت دارد که بسیاری از کتاب‌خانه‌های رایگان و یا حتی بدافزار‌های موجود، یک نقطه‌ی دسترسی\پاورقی{EndPoint}‌ توسط واسط‌های برنامه‌نویسی برای دسترسی به کتابخانه‌ها ایجاد کرده‌اند که برنامک‌های اندرویدی به وفور از این نفاط دسترسی استفاده می‌کنند. از طرفی تشخیص و جداسازی ترافیک اجباری و غیر اجباری موجب کاهش خطای منفی غلط می‌شود. برای شباهت‌سنجی ترافیک اجباری شامل ترافیک اصلی برنامک، از یک الگوریتم جریان‌درخواست\پاورقی{Request Flow}‌ مبتنی بر فاصله‌ی اقلیدوسی\پاورقی{Euclidian Method}‌ استفاده شده‌است. پیشنهاد جداسازی ترافیک کتابخانه‌ای و اصلی به وسیله‌ی نقطه‌های دسترسی واسط‌های برنامه‌نویسی ایده‌ای نو در این پژوهش است که هر چند کامل نمی‌تواند ترافیک‌ شبکه را جداسازی کند اما در صورت تکامل می‌تواند دقیق‌تر عمل کند.

در پژوهش دیگری که توسط آقای هه\مرجع{He2020} ارا‌ئه‌ شده‌، از یک طبقه‌بند به جهت تشخیص برنامک‌های بازبسته‌بندی شده استفاده شده است. در پژوهش اخیر، ابتدا تمامی ترافیک کاربران متصل به یک شبکه به یک کارگزار سطح فرستاده می‌شود و این کارگزار ترافیک شبکه را برچسب‌زنی\پاورقی{Labeling}‌ کرده و پس از استخراج ویژگی‌هایی نظیر محتوای\پاورقی{Packet Content}‌ اطلاعات هر بسته، آن‌ها را برای محاسبه‌ی امضا، سمت یک کارگزار مرکزی که به صورت ابری\پاورقی{Cloud}‌ خدمات ارائه می‌کند، می‌فرستد. پس از ارسال ویژگی‌های مستخرج به سمت کارگزار ابری، فرایند شباهت‌سنجی آغاز می‌گردد. به جهت حفظ کامل حریم خصوصی کاربران، تحلیل ترافیک تنها برروی ترافیک رمز‌گذاری نشده‌ی(\کد{http}) انجام می‌شود. در سمت کارگزار، با استفاده از تحلیل ترافیک شبکه‌‌ی هر کاربر، جریان اطلاعات در ترافیک برچسب‌زده شده مشخص می‌شود و سپس با حذف قسمتی از ترافیک در هر جریان به جهت کاهش اندازه، مانند پاسخ درخواست‌ها\پاورقی{Response}‌ و قسمتی از سربرگ\پاورقی{Header}‌ ترافیک، طبقه‌بندی صورت می‌گیرد. برای طبقه‌بندی از الگوریتم پرسرعت پژوهش \مرجع{11060} استفاده شده‌است.

مالک و همکاران\مرجع{1145} در پژوهش دیگری تحت عنوان \کد{CREDROID} از یک روش مبتنی بر درخواست نام دامنه\پاورقی{Domain Name Requests}‌ برای تشخیص برنامک‌‌های بازبسته‌بندی شده استفاده کرده است.در این پژوهش ابتدا ترافیک کاربر برای تحلیل به یک کارگزار مورد اعتماد فرستاده شده و فرایند بررسی عمیق ترافیک مورد نظر آغاز می‌شود. در ادامه و در سمت کارگزار مورد اعتماد، ترافیک کاربر ارزیابی شده و درخواست‌های نام دامنه جداسازی و برای هر کاربر برچسب‌گذاری می‌شود. در قسمت شباهت‌سنجی ترافیک درخواستی، از یک روش مبتنی بر فاصله‌ی اقلیدوسی جهت بررسی متن درخواست‌های دامنه استفاده می‌شود و در نهایت برنامک‌‌های بازبسته‌بندی شده شناسایی می‌شوند.

از آن‌جایی که بازبسته‌بندی برنامک‌های اندرویدی روشی محبوب برای حمله‌کنندگان به جهت تزریق و گسترش بدافزار‌های اندرویدی است، تمرکز          پژوهش ایلند و همکاران \مرجع{Iland2011DetectingAM} بر روی برنامک‌های اندرویدی بازبسته‌بندی شده و حاوی ترافیک مشکوک به بدافزار، با توجه رفتار مدل‌شده بر اساس درخواست‌های دامنه می‌باشد. این روش، مبتنی بر ترافیک حاصل از درخواست نام دامنه توسط برنامک‌های بازبسته‌بندی شده و سپس ارتباط آن با آدرس به دست آمده از درخواست بوده‌ است. سپس ترافیک فرستاده‌شده از سمت کاربر برای آدرس‌هایی که به دست آمده‌اند بازبینی شده و جمع‌آوری می‌شود و در ادامه با استفاده از روشی مبتنی بر تطابق رشته‌های\پاورقی{String Matching}‌ درخواست، شباهت‌سنجی صورت گرفته و برنامک‌های بازبسته‌بندی شده مشخص می‌شوند. یکی از ایرادات این پژوهش آن است که مبتنی بر رفتار بدافزار‌های بیشتر شناخته‌شده انجام شده‌است و در صورتی که بدافزاری رفتار مشابه با بدافزار‌های محبوب نداشته باشد شناسایی نمی‌شود. همچنین تحلیل ترافیک شبکه‌ی کاربر در ترافیک خام و رمزگذاری‌نشده صورت می‌گیرد و در صورتی که ارتباطات بدافزار بازبسته‌بندی شده حاوی ترافیک رمز‌گذاری‌شده باشد، آن‌گاه روش پیشنهادی در تشخیص آن‌ها ناتوان خواهد بود.

استفاده از روش‌های ترکیب با تحلیل ترافیک شبکه نظیر بررسی دسترسی‌های کاربران، در پژوهش شارما و همکاران \مرجع{8226303} استفاده شده‌است. تشخیص برنامک‌های بازبسته‌بندی شده در این پژوهش مبتنی بر طبقه‌بندی برنامک‌ها با استفاده از تحلیل ترافیک شبکه و بررسی مجوز‌های دسترسی مورد نیاز برنامک می‌باشد. پس از دیس‌اسمبل برنامک، مجوز‌های دسترسی از فایل فراداده‌ی\پاورقی{Manifest File}‌ برنامک مورد نظر استخراج شده و تشکیل یک بردار ویژگی دودویی را می‌دهند. این پژوهش از دو سطح برنامک‌های مورد نظر را بررسی می‌کند، در سطح اول اگر بردار ویژگی برنامک با برداری از برنامک‌های بازبسته‌بندی شده تطابق داشته باشد، آن‌گاه برنامک مورد نظر به عنوان یک برنامک مشکوک به سطح بعد فرستاده می‌شود. در سطح دوم، ترافیک رمزگذاری‌نشده‌‌ی برنامک تفکیک شده و تحلیل روی ترافیک \کد{TCP} ادامه می‌یابد، سپس با استفاده از یک طبقه‌بند درخت تصمیم\پاورقی{Decision Tree}‌، برنامک‌های بازبسته‌بندی شده با استفاده از تحلیل ترافیک کاربران،‌مشخص می‌شوند.

اگر چه پژوهش‌های صورت‌گرفته در این دسته معمولا سرعت خوبی از نظر مقایسه‌ی مدل استخراج شده‌ دارند، اما باید توجه داشت که محدودیت‌های موجود در این قسمت مانند به خطر افتادن حریم خصوصی کاربران، از طریق بررسی ترافیک رمز‌نگاری شده، یکی از ویژگی‌های منفی پژوهش‌های مبتنی بر ترافیک برنامک می‌باشد. از طرفی، بسیاری از برنامک‌های اندرویدی، به صورت برون‌خط فعالیت می‌کنند که موجب می‌شود روش‌های این دسته اساساً از بررسی آن‌ها ناکام بمانند.


\زیرزیرقسمت{روش‌های مبتنی بر تحلیل منابع}
عمده‌ی روش‌های موجود در این دسته، فرض استفاده از منابع برنامک‌های بازبسته‌بندی شده را در تعریف بازبسته‌بندی اعمال کرده‌اند. در این دسته از تعریف بازبسته‌بندی، متقلب با تغییر کد‌های برنامک و استفاده‌ی مستقیم از منابع آن، سعی در جعل برنامک اصلی دارد. در این حالت رابط کاربری برنامک مشابه با رابط کاربری برنامک اصلی است اما کارکرد منطقی آن دجار تغییرات زیادی می‌شود بنابراین شناسایی این دسته از برنامک‌ها با استفاده از ویژگی‌های مبتنی بر منابع آن انجام می‌شود. به عنوان اولین پژوهش از این دسته، شائو و همکاران\مرجع{6754}، برای تشکیل امضا هر برنامک، از دو دسته ویژگی آماری\پاورقی{Statistical}‌ و ساختاری\پاورقی{Structural}‌ استفاده می‌کنند. در قسمت ویژگی‌های آماری، ۱۵ ویژگی شاخص از منابع برنامک‌های اندرویدی نظیر تعداد فعالیت‌ها\پاورقی{Activities}‌، تعداد مجوز‌های دسترسی، تعداد فیلتر‌های هدفمند\پاورقی{Intent Filters}‌ و میانگین تعداد فایل‌های \کد{png} و \کد{xml} استخراج می‌شود. علاوه بر این ۵ ویژگی، ۱۰ ویژگی دیگر آماری شامل میانگین فراخوانی به ۱۰ منبع پر بازدید در برنامک‌های اندرویدی،مطابق با جدول
\ref{جدول:عملگرهای مقایسه‌ای}
، استخراج می‌شود.

\شروع{لوح}[H]
\تنظیم‌ازوسط
\شرح{10 منبع پربازدید در پژوهش \مرجع{6754}}

\شروع{جدول}{|c|c|}
\خط‌پر
\سیاه \# & \سیاه نوع منبع \\
\خط‌پر \خط‌پر
\کد{1} &  id \\
\کد{2} & drawable‌ \\
\کد{3} &  string \\
\کد{4} &  color \\
\کد{5} &  style \\
\کد{6} &  dimen \\
\کد{7} &  layout \\
\کد{8} &  xml \\
\کد{9} &  integer \\
\کد{10} &  array \\

\خط‌پر
\پایان{جدول}

\برچسب{جدول:عملگرهای مقایسه‌ای}
\پایان{لوح}
پس از استخراج ۱۵ ویژگی آماری، دو ویژگی ساختاری دیگر مبتنی بر لایه‌ی فعالیت و کنترل‌گر رویداد‌های\پاورقی{Event Handler}‌ برنامک ساخته می‌شود. برای ساخت این دو ویژگی از یک درخت انتزاعی مبتنی بر فعالیت‌های برنامک، استفاده شده‌است. در قسمت شباهت‌سنجی، پس از نرمال‌سازی ویژگی‌های استخراج شده در مراحل قبل، از دو روش طبقه‌بندی مبتنی بر نزدیک‌ترین همسایه و طبقه‌بندی طیفی\پاورقی{Spectral Classification} برای تشخیص برنامک‌های تقلبی استفاده شده‌است.

در پژوهش دیگری که توسط لین و همکاران\مرجع{8116343} انجام شده‌است، تشخیص بازبسته‌بندی با استفاده از چکیده‌ی تصاویر موجود در فایل‌های \کد{apk} موجود در پوشه‌ی منابع، صورت می‌گیرد. در این پژوهش ابتدا چکیده‌ی تمامی تصاویر استخراج شده و شباهت‌سنجی میان آن‌ها به صورت تجمعی صورت می‌گیرد. در نهایت برنامک‌هایی که امتیاز تشابه آن‌ها از یک حد آستانه بیشتر باشد به عنوان برنامک‌های بازبسته‌بندی شده تشخیص داده‌ می‌شوند. یکی از مفروضات پژوهش، به جهت کاهش فضای مقایسه، عدم لو رفتن کلید خصوصی توسعه‌دهنده‌ی برنامک می‌باشد. علاوه بر این، استفاده از روش‌های چکیده‌سازی معمول در این پژوهش، منجر به مقاومت پایین آن‌ در مقابل مبهم‌نگاری می‌شود.

سان و همکاران\مرجع{8530040} با استفاده از تحلیل گراف فعالیت‌های برنامک،مجوعه‌ای از تصاویر ضبط‌شده\پاورقی{ScreenShot} هر برنامک را تحت هر فعالیت استخراج کرده و هر دید\پاورقی{View}‌ موجود در تصاویر را با استفاده از یک مستطیل نشان‌دهی و در نهایت به ازای هر تصویر، یک گروه از ناحیه‌ دید‌ها ساخته می‌شود. در نهایت با استفاده از ادغام نواحی و گراف فعالیت‌های برنامک، گرافی تحت عنوان گراف گروه-ناحیه ساخته می‌شود. برای مقایسه و شباهت‌سنجی، با استفاده از پیمایش  گراف‌ها، گره‌های گراف به عنوان نواحی برنامک با یکدیگر مقایسه می‌شود.  دو ناحیه در صورتی با یکدیگر یکسان هستند که تعدادی از مجموعه‌های مدل‌شده به شکل مستطیل در این نواحی با یکدیگر هم‌پوشانی داشته باشند. \\
هو و همکاران\مرجع{9069227} با بررسی برنامک‌های بازبسته‌بندی شده متوجه‌ شدند که ویژگی‌های ساختاری واسط‌های کاربری\پاورقی{User Interface}‌ همانند طول و اندازه‌ی اشکال و دکمه‌ها کم‌تر دچار تغییر می‌شود و بیشتر ویژگی‌های محتوایی مانند رنگ پس‌زمینه تغییر می‌کند. با توجه به این یافته، آن‌ها سه ویژگی مهم مبتنی بر ساختار واسط‌های کاربری را استخراج و تحت عنوان امضا‌ی برنامک استفاده می‌کنند و در ادامه، این سه ویژگی را به یک فعالیت نسبت می‌دهند. در نهایت با کنار هم قرار گرفتن سه‌تایی‌های هر فعالیت و مقایسه‌ی آن‌ها با یکدیگر برنامک‌های تقلبی مشخص می‌شوند.

هدف آقای لین در پژوهش \مرجع{Li2012JuxtappAD} کاهش نرخ منفی‌غلط و مثبت‌غلط بوده‌است. در این پژوهش از ساختار سلسله‌مراتبی\پاورقی{File Structure}‌ فایل‌های موجود در یک \کد{apk} استفاده شده‌است. ساختار سلسله مراتبی مبتنی بر فایل‌های برنامک استخراج می‌شود و گره‌های این درخت برچسب‌گذاری می‌شود. برچسب‌گذاری درخت در این پژوهش، مبتنی بر نوع فایل‌ مورد نظر آن گره انجام می‌شود چرا که برچسب‌گذاری بر اساس نام فایل‌ها، مقاومت پایینی در مقابل مبهم‌نگاری دارد و متقلب می‌‌تواند به راحتی روش را دور بزند. علاوه بر این مشکل دیگری که در این پژوهش وجود دارد، این است که در صورتی که چندین فایل از یک نوع وجود داشته باشد، گره‌های مشابه در درخت سلسله‌مراتبی به وجود می‌آید و در نهایت نرخ مثبت‌غلط به شدت افزایش پیدا‌ می‌کند. برای حل این مشکل، نویسنده‌ از یک ساختار چند مرحله‌ای برای تشخیص برنامک‌های بازبسته‌بندی شده استفاده می‌کند. در این ساختار ابتدا برچسب‌گذاری به نحوی انجام می‌شود که نرخ مثبت غلط زیادی در نتایج وجود داشته باشد و در ادامه از روشی با نرخ منفی غلط بالا استفاده می‌کند تا دقت پژوهش را افزایش دهد. شباهت‌سنجی درخت‌ها با استفاده از فاصله ویرایشی میان دو درخت انجام می‌شود. روش مورد نظر مقاومت پایینی در مقابل مبهم‌نگاری‌های ساده به خصوص افزونگی فایل‌ها، خواهد داشت چرا که متقلب می‌توان به راحتی با ایجاد تعداد زیادی فایل بلااستفاده، سیستم تشخیص را دور بزند.

گوآ و همکاران\مرجع{76544} با استفاده از طرح‌بندی\پاورقی{Layout}‌ و ایجاد درخت مبتنی بر آن برنامک‌های بازبسته‌بندی شده را تشخیص می‌دهند. ابتدا درختی از تمامی مولفه‌های از نوع منبع و با استفاده از فایل‌های $xml$، به نام درخت طرح‌بندی کامل\پاورقی{ُTotal tree layout}‌، استخراج می‌شود. درخت مذکور حاوی تمامی مولفه‌های طرح‌بندی یک برنامک اندرویدی است که تنها یک ریشه دارد. در ادامه برای مقایسه‌ و شباهت‌سنجی درخت طرح‌بندی کامل، از یک روش مبتنی بر چکیده‌سازی \کد{$CTPH$} استفاده شده‌است. 

استفاده از طرح‌بندی در پژوهش‌های مبتنی بر منابع محبوبیت زیادی دارد. برای مثال، در روش لیو و همکاران \مرجع{7846987}، ابتدا طرح‌بندی‌های مربوط به کتابخانه‌های اندرویدی حذف شده، سپس هر طرح‌بندی به یک درخت نگاشت می‌شود. به جهت مقایسه، طرح‌بندی‌های برنامک با یکدیگر ادغام می‌شوند و درخت نهایی در قالب یک فایل $xml$ کدگذاری شده و در ادامه با استفاده از مقایسه‌ی مبتنی بر چکیده‌سازی فازی فایل‌های $xml$، برنامک‌های بازبسته‌بندی شده مشخص می‌شوند. در نمونه‌ی دیگری، لیو و همکاران\مرجع{9688672} در یک ساختار دو مرحله‌ای مبتنی بر طرح‌بندی ، برنامک‌های بازبسته‌بندی شده را تشخیص می‌دهند. مرحله‌ی اول در این پژوهش شامل تشخیص برنامک‌های مشکوک به صورت درشت‌دانه\پاورقی{Coars Grain}‌ است که با استفاده از تصاویر موجود در پوشه‌ی منابع انجام می‌گیرد. در ادامه و به صورت ریز‌دانه، درخت طرح‌بندی تشکیل شده و امضا‌ی هر برنامک را تشکیل‌ می‌دهد. برای مقایسه درخت‌ها، از روش‌های مرسوم مانند فاصله ویرایشی، استفاده شده‌است.

به عنوان یکی از آخرین پژوهش‌های موجود در این دسته به جهت بهبود روش‌های \مرجع{7961511,8530040} ما و همکاران\مرجع{Ma2022}  با معرفی گراف انتزاعی طرح‌بندی\پاورقی{Abstract Layout Graph}‌ و گراف طرح‌بندی انتقالی\پاورقی{Abstract Transition Graph}‌، برنامک‌های بازبسته‌بندی شده را شناسایی می‌کنند. در این پژوهش در ابتدا طرح‌بندی‌های هر برنامک تحت عنوان یک گراف جهت‌دار مدل می‌شود که هر گره‌ گراف مذکور شامل طرح‌بندی‌های مشابه می‌باشد. در مقایسه با \مرجع{7961511}، روش ما و همکاران، از سرعت بیشتری در کدگذاری طرح‌بندی و تبدیل آن‌ها به گراف انتزاعی برخوردار است. علاوه بر این در قسمت شباهت‌سنجی و مقایسه، از روشی بهبود‌یافته، مبتنی بر یافتن تطبیق گراف بیشینه\پاورقی{Maximum Graph Matching }‌ استفاده شده که ارزیابی عملکر پژوهش نسبت به دو پژوهش مورد مقایسه، افزایش سرعت و دقت را به همراه داشته است.




\زیرقسمت{مبتنی بر تحلیل پویا}
به صورت کلی پژوهش‌های صورت‌گرفته  در این قسمت را می‌توان به دو بخش روش‌های مبتنی بر جعبه‌شن\پاورقی{SandBoxing}‌ و یا روش‌های خودکار تقسیم‌بندی کرد. در روش‌های مبتنی بر جعبه‌شن، پژوهش‌کنندگان با ایجاد محیطی شبیه‌سازی شده و تعامل حداکثری با برنامک اندوریدی مدنظر، سعی در شبیه‌سازی رفتار برنامک و جمع‌آوری مجموعه‌ای از ویژگی‌های موردنیاز به جهت مقایسه‌ با یکدیگر دارند. این دسته از روش‌های پویا دو ایراد اساسی دارند، نخست آن‌که ایجاد یک محیط شبیه‌سازی شده و اجرای هر برنامک به طوری که تمامی رفتار‌های آن‌‌را شبیه‌سازی کند، نیازمند زمان زیادی است که ممکن است روش را ناکارامد کرده و بررسی برنامک‌های موجود را محدود نماید. علاوه بر این ایجاد محیطی که بتواند به صورتی کامل رفتار برنامک را شبیه‌سازی کند نیازمند آن‌است که به نوعی تمامی خدمات هر برنامک منحصرا بررسی شود که این عملی تقریبا ناممکن است مگر آن‌که شبیه‌سازی منحصر یک برنامک خاص پیاده‌سازی شود. ایراد دوم آن‌ است که برنامک‌های بازبسته‌بندی شده که دارای بدافزار هستند، ممکن است پیاده‌سازی آن‌ها قادر به شناسایی محیط شبیه‌سازی شده باشد و در نتیجه، از اجرای قسمت‌هایی از برنامک خودداری کرده و سیستم تشخیص را به خطا بیندازد. برخلاف روش‌های مبتنی بر جعبه‌شن، روش‌های مبتنی بر تحلیل خودکار بیشتر سعی در استفاده از داده‌های کاربران واقعی برنامک‌های اندرویدی دارند. بیشتر روش‌ها در این دسته از معماری‌های ابری و کارخواه-کارگزار استفاده کرده و با استفاده از ارسال گزارشات\پاورقی{Logs}‌ از سمت کاربران شباهت‌سنجی را انجام می‌دهند.
چندین نمونه از این روش‌ها را مانند \مرجع{Adhianto2010,Lin2013} در قسمت‌های پیشین بررسی کردیم. روش‌های مبتنی بر تحلیل خود‌کار هیچ شبیه‌سازی در مورد برنامک انجام نمی‌دهند و رفتار برنامک را با توجه به رفتار کاربران مورد تحلیل قرار می‌دهند. تمرکز ما در این قسمت روی پژوهش‌هایی است که بیشتر تمرکز آن‌ها بر پیاده‌سازی روشی مبتنی بر جعبه‌شن و شبیه‌سازی رفتار برنامک‌ها بوده‌است.

در پژوهش والریو و همکاران\مرجع{1156} با استفاده از اجرای برنامک‌های اندرویدی در چندین جعبه‌شن مشهور و جمع‌آوری اطلاعات برای هر برنامک اندرویدی، یک پروفایل-استفاده\پاورقی{Usage Profile}‌ ساخته می‌شود. این پروفایل نشان‌دهنده‌ی استفاده‌ی برنامک از ۸ خدمت مبتنی بر منابع سیستمی شامل لیست‌ تماس‌ها، موقعیت‌ مکانی، پیامک‌\پاورقی{SMS}‌، شبکه‌ی ارتباطی‌ بی‌سیم\پاورقی{Wifi}‌، برنامک‌ها، باتری و تماس‌ها می‌باشد. روند کلی جمع‌آوری امضا‌ی برنامک به این شکل است که برنامک‌های موجود در مخزن توسط یک مولفه در چندین جعبه‌شن مشهور و در دسترس اجرا شده و ویژگی‌های ذکر شده استخراج می‌شود و در نهایت تشکیل یک بردار ویژگی می‌دهند. در مرحله‌ی انتهایی، بردار‌های ویژگی برنامک‌های اندرویدی با یکدیگر مقایسه شده و بسته‌های بازبسته‌بندی شده مشخص خواهند شد.

از آن‌جا که بررسی پردازش‌ برنامک‌های اندرویدی به ازای ورودی‌های یکسان می‌تواند نتایج مشابه در برنامک‌های اندرویدی داشته باشد، ژانگ و همکاران\مرجع{1136} روشی را مبتنی بر زمان مورد نیاز برای اجرای ورودی‌های یکسان توسط پردازنده\پاورقی{CPU}‌، پیاده‌سازی کرده‌اند. در این پژوهش ، ابتدا تعدادی ورودی به هر برنامک اندرویدی موجود در مخزن برای اجرا داده می‌شود و پس از اتمام پردازش، بازه‌ی زمانی اجرای پردازه در پردازنده ضبط می‌شود و تحت عنوان یک دوتایی <پردازه, زمان> نمایش داده می‌شود. ورودی‌های یکسان برای تمامی برنامک‌های مورد بررسی اجرا می‌شود و در نهایت لیستی از دوتایی‌های موجود برای هر برنامک، تشکیل امضای آن‌‌را می‌دهد. 

در روش دیگری که توسط نگویان و همکاران\مرجع{nguyen2020detecting} اجرا شده‌، برنامک‌های اندرویدی با یک روش مبتنی بر جعبه‌شن و استخراج ویژگی‌هایی از واسط‌کاربری برنامک، بسته‌های بازبسته‌بندی شده را شناسایی می‌کنند. در این پژوهش با استفاده از یک جعبه‌شن که وظیفه‌ی آن ضبط تصاویر محیط کاربر برنامک می‌باشد، تصاویری از برنامک‌های اندرویدی مورد بررسی ذخیره می‌شود. از آن‌جایی که روش‌های چکیده‌سازی مرسوم، چکیده‌ای کاملا متفاوت حتی برای کوچکترین تغییرات تولید می‌کنند، در این پژوهش از روشی مبتنی بر چکیده‌سازی ادراکی\پاورقی{Perception Hashing-Phash}‌ استفاده شده‌است. در این دسته از روش‌های چکیده‌سازی، تغییرات کوچک به همان اندازه باعث تغییرات کوچک در چکیده‌ی تولید‌شده می‌شود و فایل‌های مشابه اما با تغییرات اندک می‌توانند پس از مقایسه‌ی چکیده‌سازی ادراکی، شناسایی شوند. در مرحله‌ی شباهت‌سنجی، تصاویر ضبط‌شده از هر برنامک، با استفاده از روش‌های میانگین چکیده‌سازی\پاورقی{Average Hashing}‌، با تصاویر برنامه‌های موجود در مخزن مورد مقایسه قرار می‌گیرند و در نهایت برنامک‌های بازبسته‌بندی شده به این طریق تشخیص داده می‌شوند. 

در پژوهش دیگری که مبتنی بر واسط‌های کاربری انجام‌ شده‌است،سو و همکاران\مرجع{7181443} با استفاده از استخراج فعالیت‌های برنامک موجود در فایل‌ فراداده‌ی آن‌ها، فعالیت‌های مورد نظر را در یک محیط مبتنی بر جعبه‌شن اجرا و تصاویر حاصل از اجرای هر فعالیت را ضبط می‌کنند. در قسمت شباهت‌سنجی، اطلاعاتی از درون هر کدام از تصاویر ضبط‌شده از برنامک حین اجرای آن‌، استخراج می‌شود و تشکیل بردار ویژگی هر برنامک را می‌دهند. در ادامه با استفاده از روش‌های مبتنی بر چکیده‌سازی محلی\پاورقی{Locality Sensitive Hash}‌، شباهت بردار‌های ویژگی با یکدیگر سنجیده و در صورتی که میزان شباهت از یک حد آستانه بیشتر باشد، جفت مورد بررسی، بازبسته‌بندی‌شده‌ یکدیگر شناسایی می‌شوند. برنامک برای مقاومت بیشتر در مقابل مبهم‌نگاری از لیست فعالیت‌های برنامک استفاده کرده و نقاط ورود\پاورقی{Entry Point}‌ را از روی این لیست فعالیت مشخص می‌کند. این پژوهش، فعالیت‌های موجود در برنامک‌های اندرویدی را مستقل از یکدیگر در نظر گرفته‌است و به همین دلیل نقاط ورود متنوعی مبتنی بر هر فعالیت تعیین می‌شود، در صورتی که در اکثر برنامک‌های اندرویدی، فعالیت‌های موجود کاملا به هم وابسته هستند و گاهاً یک فعالیت نتیجه‌ی یک فعالیت دیگر است بنابراین فرض پژوهش در این قسمت به نظر اشتباه می‌باشد.

به طور کلی، تشخیص برنامک‌های اندرویدی مبتنی بر روش‌های پویا شامل استخراج ویژگی‌های متنوع ساختاری و رفتاری برنامک در حین اجرای آن در محیط‌ شبیه‌سازی شده ‌است. برای مثال، در پژوهش بلاسینگ و همکاران \مرجع{5665792} با استفاده از یک برنامک تزریق‌شده به هسته\پاورقی{Kernel}‌‌ی سیستم‌عامل، تمامی فراخوانی‌های سیستمی ناشی از اجرای برنامک در محیط جعبه‌شن، استخراج می‌شود. استخراج فراخوانی سیستمی از طریق هسته‌ی سیستم‌عامل، منجر به مقاومت بالای این روش مقابل مبهم‌نگاری می‌شود. کیم‌ و همکاران \مرجع{Kim2016}، برای تشخیص برنامک‌های بازبسته‌بندی شده، از بردار‌های ویژگی مبتنی بر فراخوانی‌های واسط‌های برنامه‌نویسی\پاورقی{API Calls}‌ استفاده کرده‌اند و در نهایت با مقایسه‌ی برنامک‌ها، مسئله‌ را حل می‌کنند.گوان و همکاران\مرجع{6545}، با استفاده از یک روش مبتنی بر معناشناسی\پاورقی{Semantic}‌ در برنامک‌های اندرویدی، بسته‌های بازبسته‌بندی شده را شناسایی می‌کنند. آن‌ها با بررسی مشکلات تشخیص در تحلیل‌های ایستا، در ابتدا گراف جریان ارتباطی مبان کلاس‌های برنامک‌ را استخراج کرده و در ادامه با استفاده از وزن‌دهی گراف، مبتنی بر ورودی و خروجی کلاس، کلاس‌های اصلی برنامک را از کلاس‌های فرعی  جدا می‌کنند. سپس متد‌های هر کلاس با استفاده از گراف جریان میان متد‌های کلاسی، به صورت نمادین اجرا می‌شوند و با بررسی تمامی جایگشت‌های ممکن به عنوان ورودی هر متد و خروجی آن‌ها، متد‌های یکسان و شبیه به هم به دست می‌آیند. تشخیص بازبسته‌بندی با استفاده از یک حد آستانه، بر اساس تعداد متد‌های یکسان مشخص می‌شود. یو و همکاران\مرجع{7961511} با استفاده از ساخت گراف فعالیت مبتنی بر واسط کاربری هر برنامک و در نهایت مقایسه‌ی گرافی، برنامک‌های بازبسته‌بندی شده را تشخیص داده‌اند. برای مقایسه‌ی گرافی، پس از وزن‌دهی گراف بر اساس تعداد تکرار هر فعالیت، از یک الگوریتم تطبیق بیشینه‌ی گراف، استفاده شده‌است.
\زیرقسمت{سایر روش‌ها}
وانگ و همکاران\مرجع{2771795} از روشی مبتنی بر طبقه‌بندی برای شناسایی کتابخانه‌های اندرویدی استفاده کرده‌اند. با توجه به این که کتایخانه‌های اندرویدی در برنامک‌های مختلف تکرار می‌شوند بنابراین جمع‌آوری دنباله‌ی فراخوانی‌ واسط‌های برنامه‌نویسی در کتاب‌خانه‌های مشابه، منجر به ساخته‌شدن دنباله‌های مشابه می‌شود. بنابراین پس از جمع‌آوری دنباله‌ی فراخوانی‌ها از برنامک‌های متعدد، طبقه‌بندی روی دنباله‌ی ورودی با استفاده از داده‌ی آموزشی انجام می‌شود و در نهایت کد‌های کتابخانه‌ای با استفاده از این روش جدا می‌شوند. در قسمت دوم از یک راه حل دو مرحله‌ای برای تشخیص برنامک‌های اندرویدی بازبسته‌بندی‌شده استفاده شده‌است. پس از حذف کد‌های کتابخانه‌ای، دنباله‌های فراخوانی واسط‌های اندرویدی در هر برنامک محاسبه و دنباله‌های موجود با یکدیگر مقایسه می‌شوند. در این مرحله، برنامک‌های مشکوک به بازبسته‌بندی تشخیص داده می‌شوند و در مرحله‌ی بعدی بررسی دقیق‌تر صورت می‌گیرد. در مرحله‌ی دوم، متغیر‌های موجود در برنامک در روشی مبتنی بر توکن\پاورقی{Token}‌، به صورت برداری نشان داده می‌شوند. به جهت شباهت‌سنجی و مقایسه‌ی بردار‌های موجود، تعداد بردار‌های یکسان، که مبتنی بر شناسه‌ی هر متغیر و نام آن است، با یکدیگر مقایسه می‌شود و در صورتی که تعداد توکن‌های مشابه، در یک جفت برنامک از یک حد آستانه بیشتر باشد، جفت مورد بررسی به عنوان بازبسته‌بندی در نظر گرفته می‌شوند. روش پژوهش، از آن‌جا که در دومرحله برنامک‌های بازبسته‌بندی شده را شناسایی می‌کند از سرعت خوبی برخوردار است، اما با استفاده از روش‌های مبتنی بر افزودن متغیر‌های بیهوده، می‌توان روش یاد‌شده را دور زد.

نیشا و همکاران\مرجع{8388984}، با استفاده از ویژگی‌های مبتنی بر مجوز‌‌های دسترسی و ایجاد بردار دودویی مجوز‌های هر برنامک، به وسیله‌ی روش‌های یاد‌گیری ماشین برنامک‌های بازبسته‌بندی شده را تشخیص می‌دهند. یکی از مشکلات روش موجود آن است که برای ایجاد مجموعه‌ی داده آزمون، از یک روش مبتنی بر کپی مجدد برنامک‌های اصلی استفاده شده‌است که باعث می‌شود روش موجود در عین داشتن دقت بالا در مورد مجموعه‌ی آزمون پژوهش، به صورت کلی مقاومت بالایی در تشخیص بازبسته‌بندی نداشته باشد. مشکل دیگر این روش، آن است که عملا تعریف تشخیص بازبسته‌بندی در این روش‌ها، حل مسئله‌ی تصمیم در مورد بازبسته‌بندی است و شامل تشخیص جفت تقلبی نمی‌شود.
\قسمت{پیش‌گیری از بازبسته‌بندی}
دیدگاه پژوهش‌های پیشین در زمینه‌ی تشخیص برنامک‌های بازبسته‌بندی شده، بررسی برنامک‌های مشکوک پس از بازبسته‌بندی توسط مهاجم بوده‌است اما
عمده‌ی پژوهش‌های موجود به جهت پیش‌گیری از بازبسته‌بندی نیازمند ایجاد تغییراتی در برنامک پیش از انتشار آن به صورت عمومی می‌باشد. این روش‌ها، از بازبسته‌بندی برنامک توسط متقلبان جلوگیری کرده و یا در صورتی که بازبسته‌بندی صورت بگیرد توسعه‌دهندگان متوجه آن خواهند‌ شد. مزیت بزرگ روش‌های پیش‌گیری از بازبسته‌بندی آن‌ است که از قطعیت بیشتری برخوردار هستند، یعنی در صورتی که بازبسته‌بندی صورت بگیرد اکثراً به صورت قطعی توانایی تشخیص و جلوگیری از انتشار برنامک‌ها را دارند. به صورت کلی پژوهش‌های اخیر در این حوزه را می‌توان به دو دسته تقسیم کرد که در ادامه به توضیح مختصری از هر‌کدام و شرح پژوهش‌های هر دسته می‌پردازیم.


\زیرقسمت{روش‌های مبتنی بر نشان‌گذاری}

در این دسته از روش‌ها که نیازمند ایجاد تغییراتی در کد برنامک توسعه‌ٰداده‌شده است، توسعه‌دهندگان قسمتی از امضا‌ی خود را تحت عنوان حق‌تکثیر\پاورقی{Copy Right}‌ که با نام نشان شناسایی می‌شود، در برنامک پنهان می‌سازند و در صورتی که برنامک‌ جدیدی بازبسته‌بندی شود با توجه به تغییر این حق‌تکثیر قادر به تشخیص و جلوگیری از بازبسته‌بندی خواهند بود. به صورت کلی روش‌های نشان‌گذاری\پاورقی{Watermarking}‌ به دو نوع ایستا و پویا تقسیم می‌شوند. در روش‌های ایستا، پیش از ساخته‌‌شدن برنامک و انتشار آن، حق‌تکثیر ایجاد و در ساختار داده‌ای و یا کد‌های برنامک تزریق می‌شود اما در روش‌های پویا، به جهت غلبه بر محدودیت روش‌های ایستا و بررسی دقیق‌تر،‌ حق‌تکثیر توسعه‌دهندگان در حین اجرای برنامک توسط کد‌های مورد توسعه ایجاد می‌شود و در ساختار آن قرار می‌گیرد. در روش‌های مبتنی بر نشان‌گذاری از یک روند مشخص برای شناسایی و تایید نشان تزریق‌شده به برنامک‌ها استفاده می‌شود که عدم بازبسته‌بندی را پیش از اجرا و یا در حین اجرا، بسته به ایستا و یا پویا بودن روش، مشخص می‌کند. از طرفی به دلیل عدم قطعیت تشخیص در عمده‌ی روش‌های تشخیص، روش‌های نشان‌گذاری و روش‌های تشخیص برنامک‌‌های بازبسته‌بندی شده می‌توانند به صورت مکمل یکدیگر عمل کنند.  در این حالت ابتدا برنامک‌های مشکوک با استفاده از روش‌های بیان‌شده در حوزه‌ی تشخیص، شناسایی می‌شوند و در ادامه به جهت اطمینان از صحت برنامک مورد نظر، توسط روش‌های مبتنی بر نشان‌گذاری، حق‌تکثیر توسعه‌دهندگان بررسی می‌شود و در صورتی که برنامک مدنظر بازبسته‌بندی شده باشد، از فروشگاه حذف خواهد شد. استفاده از هر دوی این روش‌های سرعت و دقت تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده را افزایش می‌دهد.

یکی از اولین پژوهش‌های این حوزه توسط وو وهمکاران\مرجع{2484315} انجام شده‌است. در این پژوهش ابتدا رشته‌ای از اعداد و حروف برای تولید نشان‌ مشخص می‌شود. سپس رقم مشخص‌شده در فرایندی مشخص به یک گراف جایگشت نگاشت شده و در ادامه گراف مورد نظر با استفاده از یک قطعه‌کد نشان‌داده می‌شود. برای جلوگیری از مبهم‌نگاری نشان در فرایند بازبسته‌بندی، کد ایجاد‌شده برای گراف‌ نشان‌گذاری، در قسمت‌های مختلف برنامک هدف تقسیم می‌شود. برای تایید برنامک اصلی و جلوگیری از بازبسته‌بندی از یک برنامک ثانویه که حکم فراداده‌ی برنامک اصلی را دارد استفاده می‌شود. برای ساخت برنامک ثانویه، از نمونه‌ی آزمونی که تمامی کد را پوشش دهد استفاده می‌شود هر ورودی آزمون در این نمونه، یک گرداننده دارد که هر تکه از کد نشان‌گذاری شده در قسمت قبل درون آن قرار می‌گیرد. در واقع هدف از تولید برنامک ثانویه، نگه‌داشت مکان‌هایی از برنامک اصلی است که کد نشان‌گذاری در آن قسمت‌ها قرار گرفته‌است چون همانطور که اشاره کردیم جهت جلوگیری از مبهم‌نگاری نشان‌گذاری در حین بازبسته‌بندی، کد‌های نشان‌گذاری در قسمت‌های مختلف برنامک اصلی تقسیم می‌شوند. بنابراین در صورتی که برنامک ثانویه، در دسترس متقلب قرار گیرد، می‌تواند تمامی نشان‌گذاری‌های موجود در کد را شناسایی و آن‌ها را حذف کند بنابراین توسعه‌دهندگان نمی‌توانند از بازبسته‌بندی جلوگیری کنند.

ژانگ و همکاران\مرجع{6895416}، از یک روش نشان‌گذاری مبتنی بر تصاویر نشان‌گذاری‌شده استفاده می‌کنند. نویسندگان، با توجه به این که در پژوهش\مرجع{2484315} هیچ وابستگی داده‌ای میان کد‌های نشان‌گذاری شده وجود ندارد، روشی را پیشنهاد داده‌اند تا مهاجم نتواند با تحلیل برنامک‌ و یافتن کد‌های نشان‌گذاری شده، در آن‌ها مبهم‌نگاری ایجاد کرده و سیستم تشخیص را دور بزند. در این روش، با استفاده از کاراکتر‌های اسکی\پاورقی{Ascii}‌، تصویر ورودی را کدگذاری کرده و طی یک دنباله‌ی تصادفی از رخداد‌ها، کد تولید‌شده‌ی اسکی در مسیر رخداد‌های تولید‌شده تقسیم می‌شود. به جهت این‌که از تغییر نشان‌ها توسط مهاجم جلوگیری شود، تعدادی از کاراکتر‌های تصویر ورودی را با اعداد ثابت موجود در کد برنامک جایگزین می‌سازند که موجب می‌شود تصویر ورودی تغییر چندانی نکند و در عین حال وابستگی داده‌ای میان کد‌های برنامک و تصویر ورودی ایجاد شود. یکی از مشکلات دو روش اخیر، عدم امکان بررسی اصالت برنامک توسط کاربران می‌باشد. برای رفع این مشکل رن وهمکاران\مرجع{2642977} از کد‌گذاری بلوکی مبتنی بر ساختار‌های خود‌رمزگشایی\پاورقی{Self Decryption}‌ استفاده کرده‌اند. در این پژوهش، کد نشان‌گذاری شده پس از تولید، در بلوک‌های شرطی کد برنامک مورد توسعه قرار گرفته و رمز‌گذاری صورت می‌گیرد و در حین اجرا رمز‌گشایی بلوک‌های اجرایی منجر به تایید اصالت کدنشان‌گذاری شده می‌شود.

یکی از مشکلات روش‌های مطرح‌شده در این زمینه‌ آن‌است که جلوگیری از بازبسته‌بندی همواره باید توسط توسعه‌دهندگان صورت گیرد. به همین جهت ایجاد روندی خودکار جهت جلوگیری از اجرای برنامک‌های بازبسته‌بندی شده توسط خود برنامک ایده‌ای بود که در پژوهش\مرجع{8488263} توسط سان و همکاران دنبال  شده‌است. در این پژوهش ابتدا تمامی ساختار‌های شرطی\پاورقی{Conditional Statement}‌ برنامک استخراج می‌شود و با استفاده از تحلیل و تغییر شروط به صورتی که منطق برنامک تغییر نکند، کد نشان‌گذاری شده در ساختار برنامک جایگذاری می‌شود. در نهایت با استفاده از یک جریان مبتنی بر بارگذاری پویا، در صورتی که کد نشان‌گذاری شده تغییری کرده‌باشد، از اجرای برنامک جلوگیری خواهد شد.

لوآ و همکاران\مرجع{7579771} در سال ۲۰۱۶ روشی را مبتنی بر کلید عمومی توسعه‌دهنده‌ی برنامک اندرویدی، برای جلوگیری از بازبسته‌بندی ارائه کرده‌اند. نویسندگان در طی روشی به نام شبکه‌ی پنهانی مرتبط\پاورقی{Stochstic Stealthy Network}‌، به عنوان ورودی، کد برنامک اندرویدی به همراه کلید عمومی کاربر توسعه‌دهنده‌ی برنامک را دریافت می‌کند و با استفاده  مقایسه‌ی کلید‌عمومی ثیت‌‌شده در داخل برنامک و زیررشته‌ای از محاسبات مبهم‌نگاری شده در برنامک هنگام اجرای آن، اصالت برنامک را تشخیص می‌دهند. برای به ‌دست آوردن کلید‌عمومی در حین اجرای برنامک، از ویژگی بازتاب در زبان جاوا استفاده شده‌است. یکی از مشکلات این پژوهش آن‌است که به دلیل استفاده از ویژگی بازتاب برای دستیابی به کلید‌عمومی، حمله‌کننده می‌تواند قسمتی که متد فراخوانی می‌شود را بازنویسی کرده و از طریق ورودی‌های قبلی، متد را بازفراخوانی کند. در این صورت حمله‌کننده به راحتی می‌تواند به کلید عمومی دسترسی پیدا کرده و در ادامه با کمی تحلیل ایستا، قسمتی از برنامک را که کلید‌عمومی در آن ‌ثابت‌شده‌است را بیابد.به جهت مقابله با این نوع از حملات، زنگ \مرجع{3168820} راه‌حلی مبتنی بر بمب‌های منطقی\پاورقی{Logic Bomb}‌ ارا‌ئه کرده‌است. بمب‌های منطقی، قطعه‌ کد‌های کوچکی هستند که تنها در حالاتی خاص فعال می‌شوند. در طی این روش، کد‌های نشان‌گذاری در ساختار شرط‌های منطقی در برنامک تزریق می‌شود به صورتی که برخی از این شروط‌ در طی اجرای برنامک در سیستم‌عامل کاربران معمولی اجرا می‌شود. در صورتی که مهاجم از روش‌های مبتنی بر جعبه‌سیاه استفاده ننماید، در آن صورت محیط اجرای وی محدود به تعدادی سیستم‌عامل و ویژگی‌های مبتنی بر آن خواهد بود، این در حالی است که به صورت کلی کاربران گستردگی بیشتری در تنوع این ویژگی‌ها دارند. بنابراین می‌توان شروط منطقی این بمب‌ها را به گونه‌ای نوشت، که کاربر مهاجم شانس کمی برای دسترسی به نشان‌گذاری داشته‌باشد. با استفاده از این روش، پژوهش \مرجع{7579771} توسعه یافت و تا حدودی مشکلات آن برطرف گردید، اما پژوهش جدید نیز دچار مشکلاتی شد که در ادامه به آن خواهیم پرداخت. در صورتی که کاربر بتواند با تحلیل پویا و فعال‌سازی شروط و در نهایت دسترسی به بلوک بمب‌های منطقی، پیش از اجرای کد‌های رمزگشایی شده آن‌ها را تغییر دهد، آن‌گاه می‌تواند از تشخیص اصالت برنامک جلوگیری نماید. تانر و همکاران\مرجع{76512} برای حل این مشکل از کد‌های بومی استفاده کرده‌اند. از آن‌جایی که تغییر کد‌های بومی در حین بازبسته‌بندی برای مهاجم دشوار و پرهزینه‌است، نویسندگان پس از دستیابی به کد‌های بومی و کد‌های اصلی برنامک، مجموعه‌ای از بایت‌کد‌های دالویک رمز‌نگاری شده را در قسمت‌های مختلف برنامک اندرویدی اصلی تزریق کرده و متد‌های بررسی صحت برنامک را در کد‌های بومی پیاده‌سازی می‌کنند. رمز‌نگاری بایت‌کد‌ها در کنار فراخوانی توابع بررسی صحت در کدهای بومی، موجب شده‌است که روش موجود، در مقابل تحلیل ایستا و پویا توسط مهاجم امنیت داشته باشد.
\زیرقسمت{روش‌های مبتنی بر مبهم‌نگاری}
همانطور که در فصل \ref{premliminaries} اشاره‌شد، مبهم‌نگاری یکی از روش‌های پیش‌رو برای جلوگیری از بازبسته‌بندی توسط مهاجمان است. توسعه‌دهندگان از مبهم‌نگاری استفاده می‌کنند تا تغییردادن برنامک‌های اندرویدی خود را سخت و هزینه‌بر کنند. به صورت کلی مبهم‌نگاری در وهله‌ی اول موجب می‌شود تا ساختار منطقی اصلی و به طور مشخص‌تر، بدنه‌ای اصلی منطقی برنامک از دید مهاجمان مخفی بماند. در مرحله‌ی بعدی در صورتی که مهاجم بتواند بدنه‌‌ی منطقی اصلی برنامک‌ اندرویدی قربانی را شناسایی کند، تغییردادن آن و سپس پیاده‌سازی منطق مهاجم به صورت یک بدافزار، کاری سخت، زمان‌بر و هزینه‌بردار خواهد بود، به طوری که ممکن است مهاجم از انجام این عمل امتناع ورزد. همانطور که در فصل پیش دیدیم، برخی از ابزار‌های موجود، مبهم‌نگاری در برنامک‌های اندرویدی را انجام می‌دهند. اما پژوهش‌های موجود در این قسمت نیز، به صورت پیش‌رو، روش‌هایی را توسعه داده‌اند که می‌توانند نقش پیش‌گیری در بازبسته‌بندی برنامک‌های اندرویدی را داشته باشند.

یکی از روش‌های مبهم‌نگاری در برنامک‌های اندرویدی، تغییر نام شناسه‌ها، کلاس‌ها و متد‌های برنامک می‌باشد. این روش موجب می‌شود تا تحلیل و جست‌وجوی رشته‌ها در برنامک دشوار شده و مهاجم نتواند با تحلیل برنامک، آن را تغییر دهد. از آن‌جایی که تغییر نام در بیشتر مواقع تاثیری بر منطق برنامک ندارد، تغییر نام شناسه‌های برنامک، ‌روشی است که ورمک و همکاران\مرجع{3274726} از آن استفاده کرده‌اند. پروگارد ابزار دیگری است که با تغییر نام کلاس‌ها، متد‌ها و شناسه‌های موجود در برنامک مبهم‌نگاری را انجام می‌دهد. تغییر نام در پروگارد با استفاده از کاراکتر‌های محدود اسکی صورت می‌گیرد، به همین جهت دکس‌گارد معرفی شد تا نسخه‌ی پیشرفته‌تری از پروگارد را ارائه دهد که تغییر نام در آن‌ها با دامنه‌ی بیشتری از کاراکتر‌های اسکی انجام شود\مرجع{virusbulletinVirusBulletin}.

برنامک‌های مبتنی بر زبان جاوا، با استفاده از پیشوند‌های مشخص\پاورقی{ٔNameSpace}‌ گروه‌بندی می‌شوند و در یک مسیر جاری قرار می‌گیرند که موجب می‌شود کلاس‌های موجود در یک گروه به صورت مستقیم به کلاس‌های هم‌گروهی خود دسترسی داشته باشند. تغییر نام بسته‌های اندرویدی، یکی از روش‌های معمول به جهت جلوگیری در بازبسته‌بندی است چرا که موجب می‌شود تحلیل برنامک برای مهاجم سخت شود. وانگ و همکاران\مرجع{7972730} از این روش برای افزایش مقاومت مقابل مبهم‌نگاری استفاده کرده‌اند. در روشی که توسط نویسندگان پیاده‌سازی شده‌است، تعدادی کلاس کمکی برای مخفی کردن کلاس‌های اصلی برنامک به بسته‌های نرم‌افزاری اضافه‌ شده‌است. پژوهش\مرجع{virusbulletinVirusBulletin} نیز در تولید ابزار پروگارد از تغییر نام بسته‌ها استفاده کرده‌ است.

حذف کد‌های بومی‌ای که در هنگام اجرای برنامک نیازمند آن‌ها نیستیم، روش دیگری از مبهم‌نگاری برنامک‌های اندرویدی است که در پژوهش علم و همکاران \مرجع{ALAM2017230} از آن استفاده شده‌است. حذف کد‌های بومی موجب می‌شود که خوانایی برنامک در حین دی‌کامپایل توسط مهاجمان کاهش یابد. علاوه بر این موضوع، به جهت خوانایی پایین کد‌های بومی نسبت به بایت‌کد‌های دالویک که یک زبان میانی محسوب می‌شود، در پژوهش علم و همکاران \مرجع{ALAM2017230}، نویسندگان قسمتی از برنامک را که شامل الگوریتم‌های رمزنگاری می‌شود، به صورت کد‌های بومی پیاده‌سازی کرده‌اند که موجب می‌شود خوانایی این الگوریتم‌ها و در نتیجه دسترسی به الگوریتم‌های رمز‌گشایی سخت شود.

تغییر گراف کنترل جریان، روشی دیگری است که برای مبهم‌نگاری از آن استفاده می‌شود. تحلیل گراف کنترل جریان توسط مهاجمان، یکی از روش‌های محبوب بدافزارنویسان برای واردساختن بدافزار و بازبسته‌بندی است. گراف کنترل جریان نشان‌دهنده‌ی روال فراخوانی میان متد‌های یک برنامک را نشان می‌دهد. باسی و همکاران\مرجع{3232823} با استفاده از افزودن یال به گراف جریان، آن را تغییر می‌دهند. افزودن یال با استفاده از اضافه کردن یک گره جدید در میان هر فراخوانی و ایجاد فراخوانی واسط انجام می‌شود. پردا و همکاران\مرجع{preda2017testing} از همین روش برای تغییر گراف جریان استفاده کرده‌اند با این تفاوت که متد میانی اضافه‌شده، به صورت ایستا و با همان ورودی‌های متد اصلی تعریف می‌شود تا شناسایی متد‌های اصلی فراخواننده دشوار شود. افزودن کد‌های بیهوده، روشی دیگری است که در پژوهش‌های\مرجع{54311,8650141,2484355}، استفاده شده‌است. در پژوهش لی و همکاران\مرجع{54311}، با استفاده از افزودن کد‌های nop، پرش‌های قطعی\پاورقی{Unconditional Jump}‌ و ثبات‌های داده\پاورقی{Data Register}‌ پردازش‌های بیهوده‌‌ای در برنامک اضافه می‌کنند که منطق برنامک را تغییر نمی‌دهد. راستوگی \مرجع{2484355}، حالتی از دستورات شرطی را معرفی کرد که همواره یک نتیجه می‌دهد اما گراف جریان را به دو شاخه تقسیم می‌کند. در این حالت یکی از حلقه‌های این دستور، شامل کد اصلی خواهد بود و حلقه‌ی دیگر شامل پرش بدون‌شرط به ابتدای کد اصلی. ژانگ \مرجع{8650141} در پژوهش خود از این روش برای مبهم‌نگاری برنامک‌های اندرویدی استفاده  کرده‌است. جابه‌جایی دستورات، روش دیگری است که در پژوهش‌های \مرجع{virusbulletinVirusBulletin,54311,preda2017testing} استفاده شده‌است. باسی و همکاران\مرجع{54311} با استفاده از جابه‌جایی دستورات به صورت کاملا تصادفی، با دانه‌\پاورقی{Seed}‌های ناهم‌گون و در نهایت استفاده از دستورات پرش، خطوط کد‌های اصلی را جابه‌جا کرده و به این شکل مهاجم را در تحلیل کد‌‌های اصلی برنامک، ناکام می‌گذارد. پردا و همکاران\مرجع{preda2017testing} با تحلیل دالویک‌ بایت‌کد‌ها، بلوک‌های مستقل اجرایی در آن‌ها را استخراج کرده و ترتیب آن‌ها را عوض می‌کنند. برای تضمین اجرای منطق اصلی برنامک، از شرط‌های منطقی قطعی استفاده شده‌است.

استفاده از رمزگذاری در حین کامپایل برنامک‌های اندرویدی و دسترسی به اطلاعات در حین اجرا، یکی دیگر از روش‌های مبهم‌نگاری است که در سال‌های اخیر محبوبیت زیادی پیدا کرده‌است. روش‌های رمز‌گذاری را به صورت کلی می‌توان به دو دسته‌ی رمز‌گذاری داده و رمزگذاری منابع برنامک تقسیم کرد. در روش‌های مبتنی بر رمز‌گذاری داده، قسمت‌های حساسی از کد برنامک، مانند کلید‌ دسترسی به واسط‌های برنامه‌نویسی و یا گذرواژه‌های مهم مانند آنچه برای درخواست از پایگاه‌داده مورد استفاده قرار می‌گیرد، رمز‌گذاری می‌شود.باسی و همکاران\مرجع{3232823} با استفاده از این ایده و استفاده از رمز‌گذاری مبتنی بر سیستم رمز سزار\پاورقی{Caesar Cipher}‌، گذرواژه‌های حساس و حیاتی برنامک را رمزنگاری و در هنگام اجرا رمز‌گشایی می‌کند. منابع برنامک‌های اندرویدی، نیازمند کامپایل توسط ماشین مجازی جاوا نیستند و توسط کد‌های برنامک، فراخوانی می‌شوند. پردا و همکاران\مرجع{preda2017testing} با استفاده از چکیده‌سازی ۱۲۸ بیتی مبتنی بر \کد{MD5}، فایل‌های منابع را چکیده و آن‌ها را در مسیر جدیدی مقدار‌دهی می‌کند. از مشکلات این پژوهش آن‌است که نویسندگان به درستی، نحوه‌ی کارکرد کلاسی را که وظیفه‌ی بارگیری پویای فایل‌های منابع رمزشده را بر عهده دارد، مشخص نکردند. علاوه بر رمز‌گذاری منابع و اطلاعات حساس، رمز‌گذاری کلاس‌های برنامک نیز روش دیگری است که دیوید و همکاران\مرجع{MAIORCA201516} از آن استفاده کرده‌اند. در این پژوهش، هر یک از کلاس‌های اندرویدی پس از رمز‌گذاری، در آرایه‌هایی از جنس بایت ذخیره می‌شود و کلاسی مجزا در هنگام اجرا، با استفاده از قابلیت بازتاب در برنامک‌های جاوا، کلاس رمز‌گذاری شده را بازیابی و اجرا می‌کند.

به صورت کلی می‌توان تاثیر پژوهش‌های مبهم‌نگاری بر برنامک‌های اندرویدی را از سه دید‌گاه بررسی کرد. در حالت اول مبهم‌نگاری‌هایی نظیر تغییرنام و یا اجرای کلاس‌های رمز‌گذاری‌شده، منجر به \مهم{افزایش امنیت و جلوگیری از بازبسته‌بندی} می‌شود. در حالت دوم، رمز‌گذاری داده‌ها و یا استفاده از کد‌های بومی در هنگام اجرا، \مهم{مانع از اجرای تحلیل بدافزار} روی برنامک مورد نظر می‌شود. در حالت پایانی، روش‌های مبهم‌نگاری نظیر چکیده‌سازی، تغییر نام و یا حذف کد‌های مرده و بیهوده، منجر به \مهم{افزایش کارایی} و بهینه‌شدن اجرای برنامک‌های اندرویدی می‌شود. از آن‌جایی که مهاجمان نیز از روش‌های مبهم‌نگاری استفاده می‌کنند، بنابراین آشنایی با پژوهش‌های اخیر موجود در این حوزه می‌تواند ما را در ارائه‌ی روشی با دقت بیشتر و سرعت بالاتر یاری دهد.
\قسمت{مقایسه‌ی روش‌ها}
با توجه به تحلیل‌های ارایه‌شده بر روی پژوهش‌های صورت گرفته در زمینه تشخیص برنامک‌های بازبسته‌بندی در این فصل، می‌توان گفت که اکثر پژوهش‌های موجود در این زمینه، نیازمند تقویت ایده‌ی اولیه هستند و هنوز پژوهش کاملی در این زمینه که علاوه بر دقت بالا، سرعت تشخیص مناسبی نیز داشته باشد، توسعه داده نشده‌است. اما به صورت کلی، در مقایسه‌ی روش‌های پویا و ایستا می‌توان گفت که عمده‌ی روش‌های موجود با تمرکز بر \textbf{تحلیل ایستا }سعی در افزایش کارایی روش‌های پیشین دارند. علت این موضوع آن است که تحلیل ایستا پاسخ‌گوی طیف وسیعی از برنامک‌های اندرویدی خصوصا برنامک‌های رایگان است در حالی که پژوهش‌های موجود در زمینه‌ی تحلیل پویا، اکثرا از مجموعه‌ی داده‌ی آزمون کوچک و محدودی، خصوصا در زمینه‌ی برنامک‌های تجاری، استفاده کرده‌اند. علت دیگر این موضوع آن است که تهدید اصلی کاربران در زمینه‌ی برنامک‌های اندرویدی بازبسته‌بندی شده، از سمت برنامک‌های رایگان رخ می‌دهد و برنامک‌های غیررایگان و تجاری، معمولا پیش از توسعه به طور کاملی از روش‌های جلوگیری از بازبسته‌بندی استفاده می‌کنند. پژوهش پیاده‌سازی شده در این پایان‌نامه، مبتنی بر تحلیل ایستا با استفاده از گراف و استخراج ویژگی‌های مقاوم در مقابل مبهم‌نگاری است، بنابراین در ادامه‌ی این پژوهش، مقایسه‌ی روش‌های مبتنی بر تحلیل ایستا را انجام خواهیم داد. اگر به طور کلی دو معیار دقت و سرعت اجرا را در دسته‌ روش‌های مبتنی بر تحلیل ایستا در نظر بگیریم، روش‌های مبتنی بر گراف از دقت بالایی در تشخیص برخوردار هستند چرا که تغییر گراف‌های حاصل از فراخوانی و یا اجرای‌ی برنامک سخت و هزینه‌بر است اما به صورت کلی، از آن‌جایی که الگوریتم‌های مقایسه‌ی گرافی، به خصوص الگوریتم‌های تشخیص گراف هم‌ریخت، سرعت بسیار پایینی در  مقایسه دارند، معمولا روش‌های این دسته به قدری کند هستند که عملا استفاده از آن‌ها در یک ایزار کاربردی و محیط صنعتی ناممکن خواهد بود. از طرفی روش‌های مبتنی بر تحلیل ترافیک و تحلیل منابع، خصوصا در روش‌هایی که از طبقه‌بندی استفاده می‌شود، از سرعت بالایی در تشخیص برخوردار هستند اما به جهت این‌که ایجاد مبهم‌نگاری در منابع برنامک آسان و کم‌هزینه‌است، بنابراین بازبسته‌بندی ممکن است مبتنی بر منابع برنامک نیز اتفاق بیافتد. علاوه بر این، هدف بسیاری از برنامک‌های بازبسته‌بندی، فریب کاربران ناآگاه با استفاده از ایجاد یک واسط کاربری مشابه با برنامک اصلی است، بنابراین بررسی این دسته از ویژگی‌ها می‌تواند ما را در تشخیص برنامک‌های اندرویدی بازبسته‌بندی شده یاری دهد. در جدول \ref{demo} پژوهش‌های مطرح مبتنی بر تحلیل ایستا را از نظر سه خاصیت یعنی \textbf{جست‌وجوی دودویی، سربار زمانی و دقت تشخیص} مورد مقایسه قرار داده‌ایم.
\\

\begin{table}[]
	\caption{\label{demo}مقایسه‌ی روش‌های مبتنی بر تحلیل ایستا}
	\begin{tabular}{llccccc}
		
		&  & دسته‌بندی روش‌ها                                                                                 & پژوهش‌کنندگان                         & سربار محاسباتی             & دقت تشخیص                  & مقایسه‌ی دودویی                 \\ \cline{3-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ژو وهمکاران\مرجع{opcode1}}      &              \multicolumn{1}{|c|}{متوسط}               & \multicolumn{1}{c|}{پایین}      & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ژو و همکاران\مرجع{Gonzalez2015}}     &             \multicolumn{1}{|c|}{متوسط}                & \multicolumn{1}{c|}{پایین}      & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{دزنور و همکاران\مرجع{6149548}}  &             \multicolumn{1}{|c|}{متوسط}                & \multicolumn{1}{c|}{پایین}      & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}مبتنی بر آپکد و\\  دنباله‌ی دستورات\end{tabular}}                                                                            & \multicolumn{1}{c|}{جرومه و همکاران\مرجع{6883436}}  &          \multicolumn{1}{|c|}{متوسط}                   & \multicolumn{1}{c|}{پایین}      & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{4-7}  
		&  & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{سرنیل و همکاران\مرجع{6566472}}  & \multicolumn{1}{|c|}{متوسط}                       & \multicolumn{1}{|c|}{پایین} & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{4-4} \cline{7-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{لین و همکاران\مرجع{Lin2013}}    &               \multicolumn{1}{|c|}{متوسط}              & \multicolumn{1}{c|}{پایین}      & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{3-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{سان و همکاران\مرجع{wu2012}}    & \multicolumn{1}{|c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{هو و همکاران\مرجع{6911805}}     & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ژو و همکاران\مرجع{Zhou2013}}     & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}مبتنی\\  بر گراف\end{tabular}}                    & \multicolumn{1}{c|}{چن و همکاران\مرجع{Chen2014}}     & \multicolumn{1}{c|}{کم}    & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{جنگ و همکاران\مرجع{7752544}}    & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{وانگ\مرجع{phdwang}}             & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ترکی\مرجع{msctorki}}             & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{3-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{الشهری و همکاران\مرجع{Alshehri2022}} & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{پایین} & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}مبتنی بر تحلیل\\  ترافیک شبکه\end{tabular}}       & \multicolumn{1}{c|}{هه و همکاران\مرجع{He2020}}     & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{پایین} & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{مالک و همکاران\مرجع{1145}}   & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{پایین} & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ایلند و همکاران\مرجع{Iland2011DetectingAM}}   & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{پایین} & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{شارما و همکاران\مرجع{8226303}}  & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{3-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{شائو و همکاران\مرجع{6754}}   & \multicolumn{1}{c|}{کم}    & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{×}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{سان و همکاران\مرجع{8530040}}    & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                        & \multicolumn{1}{c|}{هو و همکاران\مرجع{9069227}}     & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{مبتنی بر تحلیل منابع}                                                                            & \multicolumn{1}{c|}{لین و همکاران\مرجع{Li2012JuxtappAD}}    & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{پایین} & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{گوآ و همکاران\مرجع{76544}}    & \multicolumn{1}{c|}{زیاد}  & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{لیو و همکاران\مرجع{7846987}}    & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
		&  & \multicolumn{1}{c|}{}                                                                            & \multicolumn{1}{c|}{ما  و همکاران\مرجع{Ma2022}}    & \multicolumn{1}{c|}{متوسط} & \multicolumn{1}{c|}{خوب}   & \multicolumn{1}{c|}{\textbf{\checkmark}} \\ \cline{4-7} 
	\end{tabular}
	
\end{table}