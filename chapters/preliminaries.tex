
\فصل{مفاهیم اولیه}
\label{premliminaries}
در این فصل مفاهیمی را که به صورت مستقیم و غیرمستقیم در این پژوهش از آن‌ها استفاده شده‌است را شرح ‌می‌دهیم. آشنایی با مفاهیم مطروحه در این فصل، منجر به درک بهتر پژوهش و راه‌حل پیشنهادی در فصل 
\ref{ourwork}
خواهد شد.
\قسمت{مبهم‌سازی} 
آن‌چنان که در فصل پیشین گفته‌شد، مبهم‌سازی را می‌توان از دو دیدگاه تهاجمی و تدافعی بررسی کرد. در این قسمت ما با توجه به هدف پژوهش که تشخیص بازبسته‌بندی به جهت دفاع می‌باشد، مبهم‌سازی را فرایندی در نظر می‌گیریم که در آن فرد مهاجم یا به بیان دیگر متقلب، برنامک اصلی را دانلود کرده و پس از دیکامپایل\پاورقی{Decompile} کردن، به نوعی تغییر می‌دهد که منطق کلی برنامک، تغییری نمی‌کند. مبهم‌سازی یکی از ارکان اصلی در فرایند بازبسته‌بندی ‌است و هدف اصلی آن این است که ابزار‌های تشخیص بازبسته‌بندی، خصوصا در مواردی که از تحلیل ایستا استفاده می‌کنند را به اشتباه بیاندازد.
\\
روش‌های مبهم‌سازی را از نظر میزان سختی در تشخیص به ۳ دسته‌ی کلی می‌توان تقسیم کرد\مرجع{Dong2018}: 
\زیرقسمت{روش‌های ساده}
راهکار‌های موجود در این دسته عمدتاً بدون تغییر در برنامک اصلی رخ می‌دهد. در این روش متقلب پس از آن‌که به کد‌های برنامک اصلی دسترسی پیدا کرد، آن را بدون هیچ گونه تغییری کامپایل و بسته‌بندی می‌کند‌. بازبسته‌بندی تنها موجب تغیر در امضا‌ء توسعه‌دهنده‌ی برنامک  و جمع‌آزما\پاورقی{Checksum}می‌شود. بنابراین روش‌هایی که مبتنی بر این دو خصوصیت هستند در این سطح دچار مشکل می‌شوند.
\زیرقسمت{روش‌های میانی}
\label{miani}
این دسته از روش‌های مبهم‌سازی، شامل روش‌هایی است که در آن بیشتر ویژگی‌های مبتنی بر معناشناسی\پاورقی{Semantic} تغییر می‌کند و ویژگی‌های مبتنی بر نحو\پاورقی{Syntax} ثابت باقی می‌مانند. بنابراین، روش‌هایی که بیشتر مبتنی بر معنا‌شناسی برنامک‌های اندرویدی هستند، دجار خطای بیشتری در این سطح از مبهم‌نگاری می‌شوند.در ادامه به معرفی مختصری از انواع روش‌های مبهم‌نگاری مطابق با پژوهش  \مرجع{Rastogi2013}‌ در این دسته می‌پردازیم:
\شروع{فقرات}
\فقره \مهم{تغییر نام شناسه\پاورقی{Identifier}‌ها:} تغییر نام شناسه‌های موجود در برنامک شامل نام کلاس‌ها، متد‌ها و یا متغیر‌ها\پاورقی{Variable}ی موجود \مرجع{Dong2018}


\شروع{شکل}[H]
\centerimg{1}{8cm}
\vspace{1em}
\شرح{نمونه‌ای از ‌مبهم‌نگاری با استفاده از تغییر نام شناسه‌ها}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\فقره \مهم{تغییر نام بسته:} در این روش مبهم‌نگاری با استفاده از تغییر نام بسته‌های برنامک صورت می‌گیرد.
\فقره \مهم{رمز‌نگاری رشته‌ها:} استفاده از رمز‌نگاری در رشته‌های\پاورقی{String} مورد استفاده از فایل‌های دکس\پاورقی{Dex Files}، موجب کاهش سطح معناشناسی می‌شود. 
\فقره \مهم{فراخوانی غیرمستقیم:} یکی از روش‌های ساده‌ی تغییر گراف فراخوانی\پاورقی{Call Graph}، استفاده از یک تابع واسط به عنوان تابع فراخواننده‌ی\پاورقی{Caller} تابع اصلی است. در این حالت تابع اولیه یک تابع واسط و تابع واسط به صورت زنجیر‌ه‌ای تابع اصلی را فراخوانی می‌کند. بدنه‌ی تابع واسط در این حالت، بسیار ساده و شامل یک فراخوانی تابع اصلی‌ است.
\\فقره \مهم{جابه‌جایی دستورات:} جابه‌حایی دستورات موجود در برنامک اصلی، یکی از روش‌های پرکاربرد توسط ایزار‌های مبهم‌نگاری است. جابه‌جایی دستورات به شکلی انجام می‌شود که استقلال هر قسمت حفظ گردد.
\فقره \مهم{جابه‌جایی ساختار‌ سلسله‌مراتبی:} در این روش، ساختار سلسله مراتبی کلاس‌های برنامک به نوعی تغییر می‌کتد که منطق کلاس‌ها دچار تغییر نشود.


\فقره \مهم{ادغام و شکستن:} می‌توان توابع و یا کلاس‌های موجود در برنامک‌های اندرویدی را ادغام کرد. برای مثال می‌توان هر جایی که یک تابع صدا زده‌شده بود، فراخوانی تابع با بدنه‌ی تابع جایگزین شود. از طرفی می‌توان بدنه‌ی چند تابع را تحت یک تابع با یکدیگر ادغام کرد. این کار ساختار توابع فراخواننده را نیز تغییر می‌دهد. از طرفی می‌توان یک تابع را به چندین تابع مشخص شکست و بدین صورت گراف جریان برنامک‌ را تغییر داد.

\فقره \مهم{وارد‌ساختن کد‌های بیهوده:} کد‌های بیهوده‌، کد‌هایی هستند که اجرا می‌شوند ولی تاثیری در ادامه‌ی روند اجرایی برنامک، ندارند. کد‌های بیهوده عموماً دارای ساختار‌های کنترلی\پاورقی{Control's Statement} و حلقه‌های نُپ\پاورقی{ٔNop} هستند که تاثیری در روند اجرای برنامک ندارند. ذکر این نکته حائز اهمیت است که در صورتی که در ساختار کد‌های بیهوده از شروط کنترلی مبتنی بر متغیر‌های پویا\پاورقی{Dynamic Variables} استفاده شود آن‌گاه دیگر تحلیل ایستای برنامک‌های اندرویدی قادر به تشخیص این نوع از مبهم‌نگاری‌ها نیست.
\فقره \مهم{وارد‌ساختن کد‌های مرده:}
یکی دیگر از روش‌های تغییر گراف‌های برنامه از جمله گراف جریان\پاورقی{Flow Graph}، اضافه‌کردن کد‌های مرده‌ای است که در ساختار گراف‌ جریان برنامک‌های اندرویدی هیچ‌گاه اجرا نمی‌شوند اما به عنوان یک گره در گراف حضور دارند. 
 
 \فقره \مهم{روش‌های دیگر:} روش‌های دیگری نظیر تغییر نام منابع مورد استفاده در برنامک‌های اندرویدی و حذف فایل اشکال‌زدایی\پاورقی{Debug File} از روش‌های دیگری است که در این سطح به وفور مورد استفاده قرار می‌گیرد.
\پایان{فقرات}

\زیرقسمت{روش‌های خاکستری}
\label{khakestari}
روش‌های موجود در این دسته، مبتنی بر نحوِ برنامک‌های اندرویدی و خصوصا زبان جاوا به وجود آمده‌است. عمده‌ی روش‌های مورد استفاده در این سطح، از خصوصیات مهم زبان جاوا به عنوان زبان اصلی در پیاده‌سازی برنامک‌های اندرویدی، استفاده می‌کنند. در ادامه به بررسی مهم‌ترین روش‌های موجود در این دسته می‌پردازیم.
\شروع{فقرات}
\فقره \مهم{بازتاب\پاورقی{Reflect}:} بازتاب یکی از ویژگی‌های مهم و پیچیده‌ی زبان جاوا می‌باشد\مرجع{oracleTrailReflection} که امکان فراخوانی‌ متد‌ها و ارتباط با کلاس‌های برنامک را به صورت پویا فراهم می‌سازد. مهاجمان با استفاده از فراخوانی متد‌ها به وسیله‌ی قابلیت بازتاب، می‌توانند نام واسط فراخوانی‌شده را پنهان سازند و بدین وسیله سطح جدیدی از مبهم‌نگاری را در برنامک‌های اندرویدی ایجاد سازند. استفاده از قابلیت بازتاب و رمز‌نگاری\پاورقی{Encryption} رشته‌ی واسط مورد نظر، به طور کامل واسط فراخوانی‌شده را پنهان می‌کند. 


\شروع{شکل}[H]
\centerimg{2}{10cm}
\vspace{1em}
\شرح{نمونه‌ای از ‌مبهم‌نگاری با استفاده از قابلیت باز‌تاب به منظور پنهان‌سازی واسط فراخوانی‌شده به نام batteryinfo}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\فقره{\مهم{رمز‌نگاری دالویک‌ بایت‌کد‌ها:}} در این روش، مهاجم در حین ساختن برنامک‌ بازبسته‌بندی شده، قسمتی مهمی از کد‌های برنامک را رمز‌نگاری کرده و در هنگام اجرا با استفاده از یک رویه‌ی رمز‌گشایی\پاورقی{Decryption}، کد‌های اصلی را بارگیری\پاورقی{Load} می‌کند. این روش عمدتاً زمانی استفاده می‌شود که مهاجم نیاز به فراخوانی توابع واسط‌های برنامه‌نویسی داشته‌باشد و قسمتی را که واسط‌ها فراخوانی می‌شوند را رمزنگاری می‌کند.
\فقره{\مهم{بارگذاری پویا‌ی کلاس‌ها\پاورقی{Dynamic Class Loading}:}} زبان جاوا از قابلیت مهمی به نام بارگیری پویا‌ی کد پشتیانی می‌کند که اجازه می‌دهد تکه کدی را که پیش از این در کد مورد توسعه‌ی یک برنامک موجود نبوده را در حین اجرا به برنامک اضافه کنیم. مهاجم با استفاده از این قابلیت زبان‌ جاوا می‌تواند قسمت‌هایی از برنامک‌ را در حین اجرای آن تغییر دهد که عملاً تشخیص آن‌ها با استفاده از تحلیل‌های ایستا امکان‌‌پذیر نیست.

\زیرقسمت{روش‌های ترکیبی}
هر ترکیبی از روش‌های گفته‌شده در سطوح مختلف را می‌توان برای مبهم‌نگاری استفاده کرد. به صورت کلی روش‌های میانی 
\ref{miani}
و روش‌های خاکستری
\ref{khakestari}
را می‌توان دو دسته‌ی مهم از انواع مبهم‌نگاری به حساب آورد که به صورت گسترده در مبهم‌نگار‌های رایگان و یا تجاری مورد استفاده قرار می‌گیرد.


\پایان{فقرات}

\زیرقسمت{انواع مبهم‌نگار‌ها}

در قسمت پیشین، دریافتیم که مبهم‌نگاری، سطوح متفاوتی دارد که متقلبان برای تولید برنامک‌های بازبسته‌بندی شده از آن‌ها استفاده می‌کنند.از آن‌جایی که بسیاری از برنامک‌های تقلبی با استفاده از مبهم‌نگار‌\پاورقی{Obfuscator}ها توسعه‌ یافته‌اند و علاوه بر این برای ابداع یک روش مفید جهت تشخیص برنامک‌های بازبسته‌بندی شده ابتدا باید انوع مبهم‌نگار‌های موجود را بررسی کرد. در پژوهشی که توسط ژانگ و همکاران\مرجع{ZHANG2021301285} انجام ‌شده،
$43\%$
از برنامک‌های بازبسته‌بندی شده‌ی مورد بررسی در این پژوهش، از مبهم‌نگاری‌های بسیار ساده‌ای نظیر تغییر نام و با استفاده از مبهم‌نگار‌های رایگان، انجام شده‌است. در ادام به بررسی چند مبهم‌نگار رایگان و تجاری\پاورقی{Commercial} می‌پردازیم. 

\شروع{فقرات}
\فقره \مهم{پروگارد}\\
پروگارد\پاورقی{\href{https://www.guardsquare.com/proguard}{Proguard}} یک نرم‌افزار متن‌باز رایگان به جهت بهینه‌سازی و مبهم‌نگاری در برنامه‌های جاوا مورد استفاده قرار می‌گیرد. بهینه‌سازی از طریق حذف کد‌های مرده و منابع بلااستفاده انجام می‌شود و مبهم‌نگاری عمدتاً با استفاده روش‌‌های مشروحه در بخش 
\ref{khakestari}
انجام می‌شود.\مرجع{guardsquareProGuardManual}

\فقره{\مهم{آلاتوری}}\\
آلاتوری\پاورقی{\href{https://allatori.com/}{Allatori}} یک مبهم‌نگار رایگان تولید‌شده توسط شرکت روسی اسماردک\پاورقی{Smardec} می‌باشد که سطوح مختلفی از مبهم‌نگاری را با توجه به فایل‌های پیکر‌بندی\پاورقی{Configuration} پوشش می‌دهد. این مبهم‌نگار از تغییرنام، مبهم‌نگاری مبتنی بر تغییر گراف‌های جریان، مبهم‌نگاری فایل‌های اشکال‌زدایی و رمز‌نگاری داده‌های رشته‌ای پشتیبانی می‌کند.\مرجع{codedemonsAllatoriJava,Wang2018}
\فقره{\مهم{دکس‌گارد}}\\
این مبهم‌نگار نسخه‌ی تجاری نرم‌افزار پروگارد است که توسط شرکت گارداسکوار\پاورقی{Guardsquare} تولید شده‌است. دکس‌گارد\پاورقی{DexGaurd} را می‌توان مشهورترین و یکی از پیچیده‌ترین مبهم‌نگار‌های موجود به حساب آورد. آخرین نسخه‌ی این نرم‌افزار انواع مبهم‌نگاری‌های سطح خاکستری نظیر بارگیری پویای کد و همچنین رمزنگاری کلاس‌ها و توابع را به صورت کامل انجام می‌دهد.
\پایان{فقرات}


\قسمت{ساختار فایل‌های برنامک‌های اندرویدی}
هر برنامک اندرویدی یک فایل فشرده‌شده با پسوند APK\پاورقی{Android Package} است که به اختصار شامل ۴ پوشه‌ی مهم و ۳ فایل می‌باشد.برای درک بهتر از روش پیشنهادی این پژوهش، در ادامه هر کدام از این قسمت‌ها را معرفی و کارکرد آن‌ را بررسی خواهیم‌کرد.\مرجع{Ardito2020}
\شروع{فقرات}
\فقره \مهم{پوشه‌ی :{res} }این پوشه شامل منابع برنامک‌های اندرویدی است که مربوط به رابط کاربری برنامک می‌شود. این پوشه در نهایت به فایل‌های {.R} نگاشت شده و هر کدام از منابع با یک شناسه\پاورقی{Resource Id} مشخص می‌گردد.

\فقره \مهم{پوشه‌ی :{lib} } فایل‌های کامپایل‌شده‌ی بومی در این پوشه قرار می‌گیرند که شامل کتابخانه‌های اندرویدی و جاوایینیز می‌گردد. استفاده از فایل‌هایی که کامپایل شده‌اند سرعت اجرای برنامک‌های اندرویدی را بالا می‌برد لذا استفاده از آن‌ها به عنوان بسته‌‌های\پاورقی{Module} از پیش آماده محبوبیت دارد.

\فقره \مهم{فایل‌ :{Classes.dex} } فایل‌های با پسوند {dex} فایل‌های دودویی\پاورقی{Binary} هستند که اطلاعات را در سطر و ستون‌های خود ذخیره می‌کنند. این فایل  در برنامک‌های اندرویدی حاوی بایت‌کد‌های دالویک است که توسط ماشین مجازی دالویک\پاورقی{Dalvik Virtual Machine} اجرا می‌شود.

\فقره \مهم{فایل :{AndroidManifest.xml} } پیکر‌بندی‌های مهم فایل‌های APK از جمله لیست مجوز‌های مورد نیاز، لیست مولفه‌ها\پاورقی{Component} و نام بسته‌ی برنامک در این فایل نوشته می‌شود.
\فقره \مهم{پوشه‌ی :{assets} } این پوشه همانند پوشه‌ی res برای منابع ایستا مورد استفاده قرار می‌گیرد با این تفاوت همه توسعه‌دهندگان در این پوشه می‌توانند عمق زیر‌پوشه‌ها را به تعداد نامتناهی افزایش دهند تا ساختار بهتری را فراهم سازند.
\فقره \مهم{پوشه‌ی :{META-INF} } این پوشه شامل اطلاعات کلید‌‌های عمومی\پاورقی{Public Key} کاربر توسعه‌دهنده‌ی برنامک است که برنامک با کلید خصوصی متناظر آن امضا شده‌است. امضا‌ی موجود در این پوشه، خاصیت صحت‌سنجی\پاورقی{Integrity} دارد اما اطلاعاتی را از توسعه‌دهنده نشر نمی‌دهد و به صورت خود‌امضا ساخته‌ می‌شود.
\فقره \مهم{فایل :{resources.arsc} } این فایل برای انجام نگاشت\پاورقی{Mapping} میان منابع موجود در پوشه‌ی \کد{resources} و شناسه‌ی هر منبع استفاده می‌شود تا بتوان در حین اجرای برنامک‌ها، هر شناسه‌ را به منبع آن ترجمه کرد.

\پایان{فقرات}


\شروع{شکل}[H]
\centerimg{3}{10cm}
\vspace{1em}
\شرح{ساختار پوشه‌ها و فایل‌های بسته‌های \کد{Apk} \مرجع{Bhatt2015}}
\برچسب{شکل:apk}
\پایان{شکل}

\قسمت{کتاب‌خانه‌های اندرویدی}
کتابخانه‌های اندرویدی، بسته‌های از پیش توسعه‌یافته هستند که توسط توسعه‌دهندگان نوشته شده و توسعه‌دهندگان اندروید به جهت سهولت در پیاده‌سازی و کمک به تسریع توسعه‌ی نرم‌افزار به وفور از این نمونه‌ها استفاده می‌کنند. کتابخانه‌های اندرویدی به صورت کلی به دوبخش کتابخانه‌های مختص برنامه‌نویسی اندرویدی و کتاب‌خانه‌های زبان جاوا تقسیم می‌شوند. در هنگام کامپایل، تمامی کتاب‌خانه‌هایی که توسعه‌دهنده هنگام توسعه‌ی برنامک، آن‌ها را استفاده کرده‌است به همراه کد‌های مورد توسعه، کامپایل شده و در ساختار سلسله مراتبی تحت فایل‌های {classes.dex} قرار می‌گیرد\مرجع{7476661}. ذکر این نکته‌ قابل توجه است که تشخیص برنامک‌های بازبسته‌بندی شده بدون شناسایی کتابخانه‌های برنامک‌ اندرویدی مورد نظر امکان‌پذیر نیست. واضح است که در صورتی که نتوانیم کتاب‌خانه‌های اندرویدی شاخص را از جفت برنامک‌های مورد بررسی جدا کنیم، آن‌گاه بخش زیادی از شباهت دو برنامک ناشی از کتاب‌خانه‌های اندرویدی و اشتراکات موجود در آن‌ها است چرا که بسیاری از کتابخانه‌ها خصوصا کتاب‌خانه‌های زبان جاوا، در هر برنامک اندرویدی موجود است. از طرفی، به دلیل عدم وجود مرز مشخصی میان کد‌های کتابخانه‌ای و کد‌های مورد توسعه توسط توسعه‌دهندگان، شناسایی کتابخانه‌های اندرویدی  تبدیل به یک چالش در زمینه‌ی تشخیص برنامک‌های بازبسته‌بندی در این حوزه شده‌است.

\قسمت{طبقه‌بندی}
طبقه‌بندی اطلاعات ورودی یکی از روش‌های مرسوم در هوش‌مصنوعی و یاد‌گیری ماشین است که توسط الگوریتم‌های طبقه‌بند انجام می‌شود. یک طبقه‌بند شامل مجموعه‌ای از الگوریتم‌\پاورقی{Algorithm}ها است که برای طبقه‌بندی و یا مرتب‌سازی\پاورقی{Sorting} داده‌های ورودی مورد استفاده قرار می‌گیرد \مرجع{classifier}. یکی از ساده‌ترین مثال‌های موجود برای طبقه‌بندی، جدا‌سازی هرزنامه‌\پاورقی{Spam}ها در سرویس‌های ایمیل است.روش‌های طبقه‌بندی نیازمند مجموعه‌ای از ویژگی‌های اطلاعات مورد بررسی به عنوان ورودی مسئله‌ می‌باشند تا پس از اجرای الگوریتم، اطلاعات مسئله‌ را بر اساس آن‌ها طبقه‌بندی کنند.



\قسمت{بازبسته‌بندی برنامک‌های اندرویدی}
با پویش عمیق در پژوهش‌های مرتبط با این حوزه در سالیان اخیر متوجه می‌شویم که تعاریف متنوعی برای بازبسته‌بندی در نظر گرفته‌شده است. برخی از پژوهش‌ها نظیر \مرجع{Shao2014,2627395} بازبسته‌بندی را در تغییر منابع و ظاهر برنامک‌ها در نظر می‌گیرند و در نهایت ویژگی‌های مبتنی بر ظاهر آن‌ها را با یکدیگر مقایسه می‌کنند در حالی که برخی از پژوهش‌های اخیر دیگر نظیر \مرجع{Crussell2012,Gonzalez2015} باربسته‌بندی مبتنی بر تغییر ویژگی‌های کد‌پایه تعریف شده‌است.البته که نمی‌توان به هیچ کدام از تعاریف بالا خرده گرفت چرا که هر دو تعریف از نظر مهاجم و اهداف تعریف شده توسط اون قابل استناد است.
 علاوه بر این یکی دیگر از اختلافات موجود در تعریف بازبسته‌بندی، وجود مبهم‌نگاری در برنامک‌های بازبسته‌بندی شده‌است. برخی از پژوهش‌ها نظیر \مرجع{Chen2020} بازبسته‌بندی را منطوط به تغییر در امضای برنامک می‌دانند اما بسیاری از پژوهش‌های به‌روز‌تر، نظیر \مرجع{Salem2015,Nguyen2020} بازبسته‌بندی را تنها به نغییر منابع و یا کد‌های برنامک تقلبی نسبت به برنامک اصلی می‌دانند. همانطور که مشاهده‌ شد، هنوز تعریف مشخصی از بازبسته‌بندی در پژوهش‌ها ارائه‌ نشده‌است اما به طور کلی می‌توان گفت که برنامک A بازبسته‌بندی یک برنامک دیگر است اگر تغییرات آن نسبت به برنامک مبدا محدود و با حفظ کارکرد و منابع برنامک اصلی باشد. این تعریف در این پژوهش نیز به عنوان تعریف مبنای بازبسته‌بندی در نظر گرفته شده‌است.








