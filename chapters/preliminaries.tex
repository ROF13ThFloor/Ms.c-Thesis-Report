
\فصل{مفاهیم اولیه}
\label{premliminaries}
در این فصل مفاهیمی را که به صورت مستقیم و غیرمستقیم در این پژوهش از آن‌ها استفاده شده‌است را شرح ‌می‌دهیم. آشنایی با مفاهیم مطروحه در این فصل، منجر به درک بهتر پژوهش و راه‌حل پیشنهادی در فصل 
\ref{ourwork}
خواهد شد.
\قسمت{مبهم‌سازی} 
آن‌چنان که در فصل پیشین گفته‌شد، مبهم‌سازی را می‌توان از دو دیدگاه تهاجمی و تدافعی بررسی کرد. در این قسمت ما با توجه به هدف پژوهش که تشخیص بازبسته‌بندی به جهت دفاع می‌باشد، مبهم‌سازی را فرایندی در نظر می‌گیریم که در آن فرد مهاجم، برنامک اصلی را دانلود کرده و آن را پس از دیکامپایل کردن، به نوعی تغییر می‌دهد که منطق کلی برنامک، تغییری نمی‌کند. مبهم‌سازی یکی از ارکان اصلی در فرایند بازبسته‌بندی شده‌است و هدف اصلی آن این است که ابزار‌های تشخیص بازبسته‌بندی، خصوصا در مواردی که از تحلیل ایستا استفاده می‌کنند، را به اشتباه بیاندازد.
\\
روش‌های مبهم‌سازی را از نظر میزان سختی در تشخیص به ۳ دسته‌ی کلی می‌توان تقسیم کرد\مرجع{Dong2018}: 
\زیرقسمت{روش‌های بدیهی}
راهکار‌های موجود در این دسته عمدتا بدون تغییر در برنامک اصلی رخ می‌دهد. در این روش متقلب پس از آن‌که به کد‌های برنامک اصلی دسترسی پیدا کرد، آن را بدون هیچ گونه تغییری تغیر می‌دهد. بازبسته‌بندی تنها موجب تغیر در امضا‌ء توسعه‌دهنده‌ی برنامک  و جمع‌آزما می‌شود و روش‌هایی که مبتنی بر این دو خصوصیت هستند در این سطح دچار مشکل می‌شوند.
\زیرقسمت{روش‌های میانی}
\label{miani}
این دسته از روش‌های مبهم‌سازی، شامل روش‌هایی است که در آن بیشتر ویژگی‌های مبتنی بر معناشناسی تغییر می‌کند و ویژگی‌های مبتنی بر نحو ثابت باقی می‌ماند. بنابراین، روش‌هایی که بیشتر مبتنی بر معنا‌شناسی برنامک‌های اندرویدی هستند، دجار خطای بیشتری در این سطح از مبهم‌نگاری می‌شوند.در ادامه به معرفی مختصری از انواع روش‌های مبهم‌نگاری مطابق با پژوهش  \مرجع{Rastogi2013}‌ در این دسته می‌پردازیم:
\شروع{فقرات}
\فقره \مهم{تغییر نام شناسه‌ها:} تغییر نام شناسه‌های موجود در برنامک شامل نام کلاس‌ها، متد‌ها و یا متغیر‌های موجود \مرجع{Dong2018}


\شروع{شکل}[H]
\centerimg{1}{8cm}
\vspace{1em}
\شرح{نمونه‌ای از ‌مبهم‌نگاری با استفاده از تغییر نام شناسه‌ها}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\فقره \مهم{تغییر نام بسته:} در این روش مبهم‌نگاری با استفاده از تغییر نام بسته‌های برنامک صورت می‌گیرد.
\فقره \مهم{رمز‌نگاری رشته‌ها:} استفاده از رمز‌نگاری در رشته‌های مورد استفاده از فایل‌های دکس، موجب کاهش سطح معناشناسی می‌شود. 
\فقره \مهم{فراخوانی غیرمستقیم:} یکی از روش‌های ساده‌ی تغییر گراف فراخوانی، استفاده از یک تابع واسط به عنوان تابع فراخواننده‌ی تابع اصلی است. در این حالت تابع اولیه یک تابع واسط و تابع واسط به صورت زنجیر‌ای تابع اصلی را فراخوانی می‌کند. بدنه‌ی تابع واسط در این حالت، بسیار ساده و شامل یک فراخوانی تابع اصلی‌ است.
\\فقره \مهم{جابه‌جایی دستورات:} جابه‌حایی دستورات موجود در برنامک اصلی، یکی از روش‌های پرکاربرد توسط ایزار‌های مبهم‌نگاری است. جابه‌جایی دستورات به شکلی انجام می‌شود که استقلال هر قسمت حفظ گردد.
\فقره \مهم{جابه‌جایی ساختار‌ سلسله‌مراتبی:} در این روش، ساختار سلسله مراتبی کلاس‌های برنامک به نوعی تغییر می‌کتد که منطق کلاس‌ها دچار تغییر نشود.


\فقره \مهم{ادغام و شکستن:} می‌توان توابع و یا کلاس‌های موجود در برنامک‌های اندرویدی را ادغام کرد. برای مثال می‌توان هر جایی که یک تابع صدا زده‌شده بود، فراخوانی تابع با بدنه‌ی تابع جایگزین شود. از طرفی می‌توان بدنه‌ی چند تابع را تحت یک تابع با یکدیگر ادغام کرد. این کار ساختار توابع فراخواننده را نیز تغییر می‌دهد. از طرفی می‌توان یک تابع را به چندین تابع مشخص شکست و بدین صورت گراف جریان برنامک‌ را تغییر داد.

\فقره \مهم{وارد‌ساختن کد‌های بیهوده:} کد‌های بیهوده‌، کد‌هایی هستند که اجرا می‌شوند ولی تاثیری در ادامه‌ی روند اجرایی برنامک، ندارند. کد‌های مرده عموماً دارای ساختار‌های کنترلی و حلقه‌های nop هستند که تاثیری در روند اجرای برنامک ندارند. ذکر این نکته حائز اهمیت است که در صورتی که در ساختار کد‌های مرده از شروط کنترلی مبتنی بر متغیر‌های پویا استفاده شود آن‌گاه دیگر تحلیل ایستای برنامک‌های اندرویدی قادر به تشخیص این قسمت‌ها نیست.
\فقره \مهم{وارد‌ساختن کد‌های مرده:}
یکی دیگر از روش‌های تغییر گراف‌های برنامه از جمله گراف جریان، اضافه‌کردن کد‌های مرده‌ای است که در ساختار گراف‌ جریان برنامک‌های اندرویدی هیچ‌گاه اجرا نمی‌شوند اما به عنوان یک گره در گراف حضور دارند. 
 
 \فقره \مهم{روش‌های دیگر:} روش‌های دیگری نظیر تغییر نام منابع مورد استفاده در برنامک‌های اندرویدی و حذف فایل اشکال‌زدایی از روش‌های دیگری است که در این سطح به وفور مورد استفاده قرار می‌گیرد.
\پایان{فقرات}

\زیرقسمت{روش‌های خاکستری}
\label{khakestari}
روش‌های موجود در این دسته، مبتنی بر نحو برنامک‌های اندرویدی و خصوصا زبان جاوا به وجود آمده‌است. عمده‌ی روش‌های مورد استفاده در این سطح، از خصوصیات مهم زبان جاوا به عنوان زبان اصلی در پیاده‌سازی برنامک‌های اندرویدی، استفاده می‌کنند. در ادامه به بررسی مهم‌ترین روش‌های موجود در این دسته می‌پردازیم.
\شروع{فقرات}
\فقره \مهم{بازتاب:} بازتاب یکی از ویژگی‌های مهم و پیچیده‌ی زبان جاوا می‌باشد\مرجع{oracleTrailReflection} که امکان فراخوانی‌ مند‌ها و ارتباط با کلاس‌های برنامک را به صورت پویا فراهم می‌سازد. مهاجمان با استفاده از فراخوانی متد‌ها به وسیله‌ی قابلیت بازتاب، می‌توانند نام واسط فراخوانی‌شده را پنهان سازند و بدین وسیله سطح جدیدی از مبهم‌نگاری را در برنامک‌های اندرویدی ایجاد سازند. استفاده از قابلیت بازتاب و رمز‌نگاری رشته‌ی واسط مورد نظر، به طور کامل واسط فراخوانی‌شده را مبهم می‌سازد. 


\شروع{شکل}[H]
\centerimg{2}{10cm}
\vspace{1em}
\شرح{نمونه‌ای از ‌مبهم‌نگاری با استفاده از قابلیت باز‌تاب به منظور پنهان‌سازی واسط فراخوانی‌شده به نام batteryinfo}
\برچسب{شکل:مبهم‌نگاری‌شناسه}
\پایان{شکل}

\فقره{\مهم{رمز‌نگاری دالویک‌ بایت‌کد‌ها:}} در این روش، مهاجم در حین ساختن برنامک‌ بازبسته‌بندی شده، قسمتی مهمی از کد‌های برنامک را رمز‌نگاری کرده و در هنگام اجرا با استفاده از یک رویه‌ی رمز‌گشایی، کد‌های اصلی را بارگیری می‌کند. این روش عمدتاً زمانی استفاده می‌شود که مهاجم نیاز به فراخوانی توابع واسط‌های برنامه‌نویسی داشته‌باشد و قسمتی را که واسط‌ها فراخوانی می‌شوند را رمزنگاری می‌کند.
\فقره{\مهم{بارگذاری پویا‌ی کلاس‌ها:}} زبان جاوا از قابلیت مهمی به نام بارگیری پویا‌ی کد پشتیانی می‌کند که اجازه می‌دهد تکه کدی را که پیش از این در منابع مورد توسعه‌ی یک برنامک موجود نبود را در حین اجرا به برنامک اضافه کنیم. مهاجم با استفاده از این قابلیت زبان‌ جاوا می‌تواند قسمت‌هایی از برنامک‌ را در حین اجرای آن تغییر دهد که عملاً تشخیص آن‌ها با استفاده از تحلیل‌های ایستا امکان‌‌پذیر نیست.

\زیرقسمت{روش‌های ترکیبی}
هر ترکیبی از روش‌های گفته‌شده در سطوح مختلف را می‌توان در مبهم‌نگاری استفاده کرد. به صورت کلی روش‌های میانی 
\ref{miani}
و روش‌های خاکستری
\ref{khakestari}
را می‌توان دو دسته‌ی مهم از انواع مبهم‌نگاری به حساب آورد که به صورت گسترده در مبهم‌نگار‌های رایگان و یا تجاری مورد استفاده قرار می‌گیرد.


\پایان{فقرات}

\زیرقسمت{انواع مبهم‌نگار‌ها}

در قسمت پیشین، دریافتیم که مبهم‌نگاری، سطوح متفاوتی دارد که متقلبان برای تولید برنامک‌های بازبسته‌بندی شده از آن‌ها استفاده می‌کنند. برای ابداع یک روش مفید جهت تشخیص برنامک‌های بازبسته‌بندی شده ابتدا باید انوع مبهم‌نگار‌های موجود را بررسی کرد. در پژوهشی که توسط ژانگ و همکاران\مرجع{ZHANG2021301285} انجام ‌شده،
$43\%$
از برنامک‌های بازبسته‌بندی شده‌ی مورد بررسی در این پژوهش از مبهم‌نگاری‌های بسیار ساده‌ای نظیر تغییر نام و با استفاده از مبهم‌نگار‌های رایگان، انجام شده‌است. در ادام به بررسی چند مبهم‌نگار رایگان و تجار می‌پردازیم. 

\شروع{فقرات}
\فقره \مهم{پروگارد}\\
پروگارد یک نرم‌افزار متن‌باز رایگان به جهت بهینه‌سازی و مبهم‌نگاری در برنامه‌های جاوا مورد استفاده قرار می‌گیرد. بهینه‌سازی از طریق حذف کد‌های مرده و منابع بلااستفاده انجام می‌شود و مبهم‌نگاری با استفاده  روش‌‌های مطروحه در بخش 
\ref{khakestari}
انجام می‌شود.\مرجع{guardsquareProGuardManual}

\فقره{\مهم{آلاتوری}}\\
آلاتوری یک مبهم‌نگار رایگان تولید‌شده توسط شرکت روسی Smardec می‌باشد که سطوح مختلفی از مبهم‌نگاری را با توجه به فایل‌های پیکر‌بندی پوشش می‌دهد. این مبهم‌نگار از تغییرنام، مبهم‌نگاری مبتنی بر تغییر گراف‌های جریان، مبهم‌نگاری فایل‌های اشکال‌زدایی و رمز‌نگاری داده‌های رشته‌ای پشتیبانی می‌کند.\مرجع{codedemonsAllatoriJava,Wang2018}
\فقره{\مهم{دکس‌گارد}}\\
این مبهم‌نگار نسخه‌ی تجاری پروگارد است که توسط شرکت گارداسکوار تولید شده‌است. دکس‌گارد را می‌توان مشهورترین و یکی از پیچیده‌ترین مبهم‌نگار‌های موجود به حساب آورد. آخرین نسخه‌ی این نرم‌افزار انواع مبهم‌نگاری‌های سطح خاکستری نظیر بارگیری پویای کد و همچنین رمزنگاری کلاس‌ها و توابع را به صورت پویا انجام می‌دهد.
\پایان{فقرات}


\قسمت{ساختار فایل‌های برنامک‌های اندرویدی}
هر برنامک اندرویدی یک یک فایل فشرده‌شده با پسوند APK است که به اختصار شامل ۴ پوشه‌ی مهم و ۳ فایل است.در ادامه هر کدام از این قسمت‌ها را معرفی و کارکرد آن‌ را بررسی خواهیم‌کرد.\مرجع{Ardito2020}
\شروع{فقرات}
\فقره \مهم{پوشه‌ی :{res} }این پوشه شامل منابع برنامک‌های اندرویدی است که مربوط به ظاهر برنامک می‌شود. این فایل در نهایت به فایل‌های {.R} نگاشت می‌شود و هر کدام از منابع با یک شناسه مشخص می‌گردد.

\فقره \مهم{پوشه‌ی :{lib} } فایل‌های کامپایل‌شده ی بومی در این پوشه قرار می‌گیرند که شامل کتابخانه‌ها نیز می‌گردد. استفاده از فایل‌هایی که کامپایل شده‌اند سرعت اجرای برنامک‌های اندرویدی را بالا می‌برد لذا استفاده از آن‌ها به عنوان ماژول‌های از پیش آماده محبوبیت دارد.

\فقره \مهم{فایل‌ :{Classes.dex} } فایل‌های با پسوند {dex} فایل‌های دودویی هستند که اطلاعات را در سطر و ستون‌های خود ذخیره می‌کنند. این فایل  در برنامک‌های اندرویدی حاوی بایت‌کد‌های دالویک است که توسط ماشین مجازی دالویک اجرا می‌شود.

\فقره \مهم{فایل :{AndroidManifest.xml} } پیکر‌بندی‌های مهم فایل‌های APK از جمله لیست مجوز‌های مورد نیاز، لیست مولفه‌ها و نام بسته‌ی برنامک در این فایل نوشته می‌شود.
\فقره \مهم{پوشه‌ی :{assets} } این پوشه همانند پوشه‌ی res برای منابع ایستا مورد استفاده قرار می‌گیرد با این تفاوت همه توسعه‌دهندگان در این پوشه می‌توانند عمق زیر‌پوشه‌ها را به تعداد نامتناهی افزایش دهند تا ساختار بهتری را فراهم سازند.
\فقره \مهم{پوشه‌ی :{META-INF} } این پوشه شامل اطلاعات کلید‌‌های عمومی کاربر توسعه‌دهنده‌ی برنامک است که برنامک با کلید خصوصی متناظر آن امضا شده‌است. امضا‌ی موجود در این پوشه، خاصیت صحت‌سنجی دارد اما اطلاعاتی را از توسعه‌دهنده نشر نمی‌دهد و به صورت خود‌امضا ساخته‌ می‌شود.
\فقره \مهم{فایل :{resources.arsc} } این فایل برای انجام نگاشت میان مننابع موجود در پوشه‌ی {resources} و شناسه‌ی هر منبع استفاده می‌شود تا بتوان در حین اجرای برنامک‌ها، هر شناسه‌ را با منبع مورد نظر ترجمه‌ شود.

\پایان{فقرات}


\شروع{شکل}[H]
\centerimg{3}{10cm}
\vspace{1em}
\شرح{ساختار پوشه‌ها و فایل‌های فایل‌های {Apk} \مرجع{Bhatt2015}}
\برچسب{شکل:apk}
\پایان{شکل}

\قسمت{کتاب‌خانه‌های اندرویدی}
کتابخانه‌های اندرویدی، نمونه‌های از پیش توسعه‌یافته هستند که توسط توسعه‌دهندگان نوشته شده و توسعه‌دهندگان اندروید به جهت سهولت در پیاده‌سازی و کمک به تسریع پیاده‌سازی به وفور از این نمونه‌ها استفاده می‌کنند. کتابخانه‌های اندرویدی به صورت کلی به دوبخش کتابخانه‌های مختص برنامه‌نویسی اندرویدی و کتاب‌خانه‌های زبان جاوا تقسیم می‌شوند. در هنگام کامپایل، تمامی کتاب‌خانه‌هایی که توسعه‌دهنده هنگام توسعه‌ی برنامک آن‌ها را استفاده کرده‌است به همراه کد‌های مورد توسعه، کامپایل شده و در ساختار سلسله مراتبی تحت فایل‌های {classes.dex} قرار می‌گیرد\مرجع{7476661}. ذکر این نکته‌ قابل توجه است که تشخیص برنامک‌های بازبسته‌بندی شده بدون شناسایی کتابخانه‌های برنامک‌ اندرویدی مورد نظر امکان‌پذیر نیست. واضح است که در صورتی که نتوانیم کتاب‌خانه‌های اندرویدی شاخص را از جفت برنامک‌های مورد بررسی جدا کنیم، آن‌گاه بخش زیادی از شباهت دو برنامک ناشی از کتاب‌خانه های اندرویدی و اشتراکات موجود در آن‌ها است چرا که بسیاری از کتابخانه‌ها خصوصا کتاب‌خانه های زبان جاوا، در هر برنامک اندرویدی موجود است. از طرفی، مرز عدم وجود مرز مشخصی میان کد‌های کتابخانه‌ای و کد‌های مورد توسعه توسط توسعه‌دهندگان، شناسایی کتابخانه‌های اندرویدی را تبدیل به یک چالش در زمینه‌ی تشخیص برنامک‌های بازبسته‌بندی در این حوزه کرده‌است.

\قسمت{طبقه‌بندی}
طبقه‌بندی اطلاعات ورودی یکی از روش‌های مرسوم در هوش‌مصنوعی و یاد‌گیری ماشین است که توسط الگوریتم‌های طبقه‌بند انجام می‌شود. یک طبقه‌بند شامل مجموعه‌ای از الگوریتم‌ها است که برای طبقه‌بندی و یا مرتب‌سازی داده‌های ورودی مورد استفاده قرار می‌گیرد \مرجع{classifier}. یکی از ساده‌ترین مثال‌های موجود برای طبقه‌بندی، جدا‌سازی هرزنامه‌ها در سرویس‌های ایمیل است.روش‌های طبقه‌بندی نیازمند مجموعه‌ای از ویژگی‌های اطلاعات ورودی به عنوان ورودی مسئله‌ می‌باشند تا پس از اجرای الگوریتم، ورودی‌های مدنظر را بر اساس آن‌ها  در چند طبقه قرار دهند.



\قسمت{بازبسته‌بندی برنامک‌های اندرویدی}
با پویش عمیق در پژوهش‌های مرتبط با این حوزه در سالیان اخیر متوجه می‌شویم که تعاریف متنوعی برای بازبسته‌بندی در نظر گرفته‌شده است. برخی از پژوهش‌ها نظیر \مرجع{Shao2014,2627395} بازبسته‌بندی را در تغییر منابع و ظاهر برنامک‌ها در نظر می‌گیرند و در نهایت ویژگی‌های مبتنی بر ظاهر آن‌ها را با یکدیگر مقایسه می‌کنند در حالی که برخی از پژوهش‌های اخیر دیگر نظیر \مرجع{Crussell2012,Gonzalez2015} باربسته‌بندی مبتنی بر تغییر ویژگی‌های کد‌پایه بیان شده‌است. علاوه بر این یکی دیگر از اختلافات موجود در تعریف بازبسته‌بندی، وجود مبهم‌نگاری در برنامک‌های بازبسته‌بندی شده‌است. برخی از پژوهش‌ها نظیر \مرجع{Chen2020} بازبسته‌بندی را منطوط به تغییر در امضای برنامک می‌دانند اما بسیاری از پژوهش‌های به‌روز‌تر، نظیر \مرجع{Salem2015,Nguyen2020} بازبسته‌بندی را تنها به نغییر منابع و یا کد‌های برنامک تقلبی نسبت به برنامک اصلی می‌دانند. همانطور که مشاهده‌ شد، هنوز تعریف مشخصی از بازبسته‌بندی در پژوهش‌ها ارائه‌ نشده‌است اما به طور کلی می‌توان گفت که برنامک A بازبسته‌بندی یک برنامک دیگر است اگر تغییرات آن نسبت به برنامک مبدا محدود و با حفظ کارکرد و منابع برنامک اصلی باشد. این تعریغ در این پژوهش نیز به عنوان تعریف مبنای بازبسته‌بندی در نظر گرفته شده‌است.








